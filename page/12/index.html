<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>シェンキンリンのブログ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="シェンキンリンのブログ">
<meta property="og:url" content="https://mrqlyn.github.io/page/12/index.html">
<meta property="og:site_name" content="シェンキンリンのブログ">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="シェンキンリンのブログ">
  
    <link rel="alternate" href="/atom.xml" title="シェンキンリンのブログ" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">シェンキンリンのブログ</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Learning records of a typist</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://mrqlyn.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android/Android里的服务Service" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/22/Android/Android里的服务Service/" class="article-date">
  <time datetime="2018-07-22T09:04:12.000Z" itemprop="datePublished">2018-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/22/Android/Android里的服务Service/">Android里的服务Service</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>版权声明：转载请说明去处，文章仅供学习参考 <a href="https://blog.csdn.net/qq_38487155/article/details/81155513" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/81155513</a><br>   学习郭霖大神的《第一行代码》，记录以下自己的学习笔记，对Service的一个总结</p>
<p> 一、继承服务类、重写服务方法</p>
<p> 当我们要自定义服务时，必须要继承于服务类（Service），重写服务的方法,同时最重要的是在注册四大组件的地方注册服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> &lt;service android:name=&quot;.MyService&quot;&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>

<p> 以下为服务的可重写方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    //绑定服务会触发方法，返回值将传入活动ServiceConnection类的onServiceConnected的参数里</span><br><span class="line">//活动调用bindService()后会回调onBind()方法返回一个IBinder实例到</span><br><span class="line">//活动匿名类ServiceConnection的onServiceConnected的传入参数里</span><br><span class="line">@Override</span><br><span class="line">public IBinder onBind(Intent intent) &#123;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line">//创建服务调用方法</span><br><span class="line">public void onCreate() &#123;</span><br><span class="line">	super.onCreate();</span><br><span class="line">&#125;</span><br><span class="line">//启动服务调用方法</span><br><span class="line">public int onStartCommend(Intent intent,int flags,int startId) &#123;</span><br><span class="line">	return super.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br><span class="line">//销毁服务调用方法</span><br><span class="line">public void onDestroy() &#123;</span><br><span class="line">	super.onDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 二、服务的启动与停止</p>
<p> 服务的启动与停止与显示启动活动类似，通过Intent指定要启动的服务，再通过startService(Intent)、startService(Intent)启动服务和停止服务，服务也可使用stopSelf()自己停止自己来终止服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	//在活动里启动服务MyService</span><br><span class="line">Intent startIntent=new Intent(this,MyService.class);</span><br><span class="line">startService(startIntent);</span><br><span class="line"></span><br><span class="line">//在活动里停止服务MyService</span><br><span class="line">Intent stopIntent=new Intent(this,MyService.class);</span><br><span class="line">stopService(stopIntent);</span><br></pre></td></tr></table></figure>

<p> 三、服务的绑定与解绑，活动对服务的操控（活动与服务之间的通信）</p>
<p> 服务的绑定可以让服务和活动之前的通信更加灵活，之前我们启动服务后，服务就运行玩onCreate()和onStartCommend()的代码后就一直运行在那，无法做其它事情。可如果使用绑定服务，活动在启动完服务后可以随时随地操控正在运行的服务（获得Binder实例），让服务能为我们做更多的事情（调用Binder里的方法）。（注意：任何一个服务在应用程序里都是通用的，服务可以与任何一个活动进行绑定）</p>
<p> 1、在<strong>自定义服务类</strong>自定义一个类继承于Binder，并自定义该类的方法（也就是服务提供给活动的方法），同时重写onBind()返回自定义Binder类的实例对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	//自定义内部类继承于Binder，自定义开始下载方法和进度方法</span><br><span class="line">private DownloadBinder downloadTask=new DownloadBinder();</span><br><span class="line">class DownloadBinder extends Binder&#123;</span><br><span class="line">	//让服务开始下载</span><br><span class="line">	public void startDownload() &#123;</span><br><span class="line">		Log.d(&quot;MyService&quot;, &quot;startDownload executed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	//让服务返回进度</span><br><span class="line">	public int getProgress() &#123;</span><br><span class="line">		Log.d(&quot;MyService&quot;, &quot;getProgress executed&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//绑定服务会触发方法，返回值将传入活动ServiceConnection类的onServiceConnected的参数里</span><br><span class="line">//活动调用bindService()后会回调onBind()方法返回一个IBinder实例到</span><br><span class="line">//活动匿名类ServiceConnection的onServiceConnected的传入参数里</span><br><span class="line">@Override</span><br><span class="line">public IBinder onBind(Intent intent) &#123;</span><br><span class="line">	// TODO Auto-generated method stub</span><br><span class="line">	return downloadTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 2、在<strong>活动类</strong>里定义匿名类ServiceConnection，并重写onServiceDisconnected()、onServiceConnected()方法来获得返回的自定义Binder类实例，同时调用bindService()、unbindService()来绑定和解绑服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">	private MyService.DownloadBinder downloadBinder;</span><br><span class="line">//ServiceConnection类：定义匿名类用来绑定，解绑服务重写调用方法</span><br><span class="line">private ServiceConnection connection=new ServiceConnection() &#123;</span><br><span class="line">	//活动解绑服务时调用</span><br><span class="line">	public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	//活动绑定服务时调用(参数IBinder为Service里onBind()返回的IBinder)</span><br><span class="line">	public void onServiceConnected(ComponentName name,IBinder services) &#123;</span><br><span class="line">		//在活动里获得服务的自定义Binder类，可调用Binder里的方法来指挥服务</span><br><span class="line">		downloadBinder=(MyService.DownloadBinder)services;</span><br><span class="line">		//让服务开始下载任务</span><br><span class="line">		downloadBinder.startDownload();</span><br><span class="line">		//获得服务的任务下载进度</span><br><span class="line">		downloadBinder.getProgress();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	//绑定服务，connection为自定义的ServiceConnection</span><br><span class="line">Intent bindIntent=new Intent(this,MyService.class);</span><br><span class="line">bindService(bindIntent,connection,BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line">//解绑服务，connection为自定义的ServiceConnection</span><br><span class="line">unbindService(connection);</span><br></pre></td></tr></table></figure>

<p> 四、启动运行在子线程的服务俩种方法</p>
<p> <strong>服务默认运行在主线程，</strong>当我们处理一些耗时任务（如下载任务等）运行在后台服务是可能会造成ANR情况，所以为了避免这种情况，我们需要让耗时任务放在子线程里执行，一般常常使用以下俩种方法：</p>
<p> 1、在onStartCommend()里开启子线程，并在最后让服务自动停止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> public int onStartCommand(Intent intent,int flags,int startId) &#123;</span><br><span class="line">	//开启了一个子线程，可执行具体后台服务代码</span><br><span class="line">	new Thread(new Runnable() &#123;</span><br><span class="line">		@Override</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			Log.d(&quot;LongRunningService&quot;,&quot;executed at&quot;+new Date().toString());</span><br><span class="line">			stopSelf();    //执行玩耗时任务后自动停止服务，当不想停止服务可将此句省略</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 2、使用IntentService类，该服务类有一特点：运行在子线程中，且运行完毕后自动停止。</p>
<p> 具体使用方法：自定义子线程服务类继承于IntentService，重写MyIntentService和onHandleIntent，然后启动该服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> public class MyIntentService extends IntentService&#123;</span><br><span class="line">	public MyIntentService() &#123;</span><br><span class="line">		super(&quot;My IntentService&quot;);	//调用父类的有参构造函数</span><br><span class="line">	&#125;</span><br><span class="line">	//子线程开启服务处理具体逻辑方法</span><br><span class="line">	@Override</span><br><span class="line">	protected void onHandleIntent(Intent intent) &#123;</span><br><span class="line">		//处理耗时任务代码</span><br><span class="line">		Log.d(&quot;MyIntentService&quot;, &quot;Thread is&quot;+Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 五、服务的后台执行定时任务例子</p>
<p> 1、自定义一个一直运行的服务，通过AlarmManager（闹钟管理器）的setExact()设置定时任务，该方法接收三个参数：</p>
<p> 第一个参数（闹钟的类型，四种）：ELAPSED_REALTIME（开始时间从系统时间算起，不唤醒CPU）、</p>
<p> ELAPSED_REALTIME_WAKEUP（开始时间从系统时间算起，唤醒CPU）、</p>
<p> RTC（开始时间从1970年1月1日0点开始算起，不唤醒CPU）、</p>
<p> RTC_WAKEUP（开始时间从1970年1月1日0点开始算起，唤醒CPU）</p>
<p> 第二个参数：定时触发时间（单位为毫秒），则闹钟在开始时间加上触发时间的时间点触发</p>
<p> 第三个参数PendingIntent：用来触发广播接收器，当任务触发是会调用广播接收器的onReceiver方法</p>
<p> 以下为获得PendingIntent的示例：</p>
<p> Intent i=new Intent(this,AlarmReceiver.class);<br> PendingIntent pi=PendingIntent.getBroadcast(this, 0, i, 0);</p>
<p> 2、在触发的广播接收器的onReceiver方法再次启动一直运行服务，形成循环。</p>
<p> //接收到广播后启动LongRunningService服务<br> Intent i=new Intent(context,LongRunningService.class);<br> context.startService(i);</p>
<p> 完整例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> public class LongRunningService extends Service&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public IBinder onBind(Intent intent) &#123;</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br><span class="line">	@TargetApi(Build.VERSION_CODES.KITKAT)</span><br><span class="line">	public int onStartCommand(Intent intent,int flags,int startId) &#123;</span><br><span class="line">		//开启了一个子线程，可执行具体后台服务代码</span><br><span class="line">		new Thread(new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				Log.d(&quot;LongRunningService&quot;,&quot;executed at&quot;+new Date().toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		AlarmManager manager=(AlarmManager)getSystemService(ALARM_SERVICE);</span><br><span class="line">		int Minute=60*1000;	//这是一分钟的毫秒数</span><br><span class="line">		long triggerTime=SystemClock.elapsedRealtime()+Minute;</span><br><span class="line">		//闹钟管理器AlarmManager设置定时任务,设置AlarmReceiver作为处理定时任务的广播接收器</span><br><span class="line">		Intent i=new Intent(this,AlarmReceiver.class);</span><br><span class="line">		PendingIntent pi=PendingIntent.getBroadcast(this, 0, i, 0);</span><br><span class="line">		manager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerTime, pi);</span><br><span class="line">		return super.onStartCommand(intent, flags, startId);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public class AlarmReceiver extends BroadcastReceiver&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">		//接收到广播后启动LongRunningService服务</span><br><span class="line">		Intent i=new Intent(context,LongRunningService.class);</span><br><span class="line">		context.startService(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrqlyn.github.io/2018/07/22/Android/Android里的服务Service/" data-id="ckjzjnci400700gtptf9li9wk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android里如何在子线程更新UI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/21/Android/Android里如何在子线程更新UI/" class="article-date">
  <time datetime="2018-07-21T08:02:20.000Z" itemprop="datePublished">2018-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/21/Android/Android里如何在子线程更新UI/">Android里如何在子线程更新UI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 版权声明：转载请说明去处，文章仅供学习参考 <a href="https://blog.csdn.net/qq_38487155/article/details/81140482" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/81140482</a><br>   一、Message：在线程间传递消息，传输少量数据</p>
<p> Handler：发送和处理消息（Message），必须定义在主线程中，如果是多个类直接互相调用，需要传递content对象</p>
<p> 或通过接口调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message有int静态变量what（判断消息），int静态变量arg1、arg2，静态Object对象obj</span><br></pre></td></tr></table></figure>

<p> Handler有以下调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendMessage(Message):发送Message</span><br></pre></td></tr></table></figure>

<p> 以下可重写方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleMessage(Message):可重写，接收Message，在此处更新UI</span><br></pre></td></tr></table></figure>

<p> 具体例子 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> //定义在主线程的Handler类，并重写handleMessage()方法</span><br><span class="line">public Handler handler = new Handler() &#123;</span><br><span class="line">        //接收Message，并对UI的处理</span><br><span class="line">		@Override</span><br><span class="line">		public void handleMessage(Message msg) &#123;</span><br><span class="line">			super.handleMessage(msg);</span><br><span class="line">			switch (msg.what) &#123;</span><br><span class="line">			case 0:</span><br><span class="line">				//完成主界面更新,拿到数据</span><br><span class="line">				String data = (String)msg.obj;</span><br><span class="line">				textView.setText(data);</span><br><span class="line">				break;</span><br><span class="line">			default:</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line">//子线程类发送消息</span><br><span class="line">public void send&#123;</span><br><span class="line">    new Thread(new Runnable()&#123;</span><br><span class="line">        public void run()&#123;</span><br><span class="line">            Message msg=new Message();</span><br><span class="line">            msg.what=0;</span><br><span class="line">            MainActivity.handler.sendMessage(message);    //发送Message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 二、.AsyncTask:子线程不能更新UI：因此在一些下载任务需要进度更新，文件读取等耗时操作,如果全部放到主线程去执行,就可能会造成后面任务的阻塞，所以使用AsyncTask进行异步操作</p>
<p> AsyncTask&lt;Params,Progress,Result&gt;是一个抽象类,通常用于被继承.继承AsyncTask需要指定如下三个泛型参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Params:启动任务时输入的参数类型.</span><br><span class="line"></span><br><span class="line">Progress:后台任务执行中返回进度值的类型.</span><br><span class="line"></span><br><span class="line">Result:后台任务执行完成后返回结果的类型.（可为Boolean判断成功失败）</span><br></pre></td></tr></table></figure>

<p> .构建AsyncTask子类的回调方法</p>
<p> AsyncTask有以下可重写方法（doInBackground必须重写，其余可写可不写）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> doInBackground（Params）：异步执行后台线程任务,耗时操作将在此方法中完成.</span><br><span class="line"></span><br><span class="line">onPreExecute（）：执行后台任务前被调用,通常用于进行初始化操作.</span><br><span class="line"></span><br><span class="line">onProgressUpdate（Progress）：:当doInBackground()方法中调用publishProgress(Progress)方法后,将自动调用此方法.通过此方法我们可以更新任务的进度，可通过此方法进行UI的更新.</span><br><span class="line"></span><br><span class="line">onPostExecute（Result）：:当doInBackground()方法完成后,系统将自动调用此方法,并将doInBackground方法返回的值(即Result)，此方法可以进行UI更新，如任务完成关闭进度条等</span><br></pre></td></tr></table></figure>





      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrqlyn.github.io/2018/07/21/Android/Android里如何在子线程更新UI/" data-id="ckjzjncbo000x0gtpo22hi9t7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android里的多媒体" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/20/Android/Android里的多媒体/" class="article-date">
  <time datetime="2018-07-20T14:40:08.000Z" itemprop="datePublished">2018-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/20/Android/Android里的多媒体/">Android里的多媒体</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 版权声明：转载请说明去处，文章仅供学习参考 <a href="https://blog.csdn.net/qq_38487155/article/details/81134944" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/81134944</a><br>   <strong>目录</strong></p>
<p> <a href="#%E4%B8%80%E3%80%81%E9%80%9A%E7%9F%A5%EF%BC%9A%E5%8D%B3%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%89%8B%E6%9C%BA%E4%B8%8B%E6%BB%91%E6%A1%86%E7%9A%84%E6%B6%88%E6%81%AF%E3%80%82">一、通知：即显示在手机下滑框的消息。</a></p>
<p> <a href="#%E4%BA%8C%E3%80%81%E7%9F%AD%E4%BF%A1">二、短信</a></p>
<p> <a href="#%E4%B8%89%E3%80%81%E6%89%93%E5%BC%80%E7%9B%B8%E6%9C%BA%E5%92%8C%E6%89%93%E5%BC%80%E7%9B%B8%E5%86%8C%EF%BC%9A%E4%BB%A3%E7%A0%81%E9%83%BD%E6%9C%89%E6%B3%A8%E9%87%8A%E7%9B%B4%E6%8E%A5%E7%9C%8B%E4%BB%A3%E7%A0%81">三、打开相机和打开相册：代码都有注释直接看代码</a></p>
<p> <a href="#%E5%9B%9B%E3%80%81%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91%E5%92%8C%E8%A7%86%E9%A2%91">四、播放音频和视频</a></p>
<hr>
<h2 id="一、通知：即显示在手机下滑框的消息。"><a href="#一、通知：即显示在手机下滑框的消息。" class="headerlink" title="一、通知：即显示在手机下滑框的消息。"></a>一、通知：即显示在手机下滑框的消息。</h2><p> NotificationManager:通知管理器， 用来发送通知、取消通知。</p>
<p> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> (NotificationManager)getSystemService(NOTIFICATION_SERVICE):获得NotificationManager</span><br><span class="line">notify(int,Notification):发送通知，传入通知的id（每个通知都不能相同）和要发送的通知</span><br></pre></td></tr></table></figure>

<p> Notification.Builder:通知构建器，用来构建通知和设置通知各种参数</p>
<p> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">	new Notification.Builder(Context):构建一个Notification.Builder</span><br><span class="line">builder.setSmallIcon(R.drawable.ic_launcher); //设置小图标（未展开时显示图标）</span><br><span class="line">              //设置大图标（展开通知后显示图标）          </span><br><span class="line">             builder.setLargeIcon(BitmapFactory.decodeResource(getResources(),R.drawable.play));</span><br><span class="line">builder.setTicker(&quot;小红给你发来了一条信息&quot;);	  //显示最先在顶部收到的通知 </span><br><span class="line">builder.setContentTitle(&quot;通知&quot;); 	//设置标题</span><br><span class="line">builder.setContentText(&quot;点击查看详细内容&quot;); //消息内容</span><br><span class="line">builder.setWhen(System.currentTimeMillis()); //发送时间</span><br><span class="line">builder.setDefaults(Notification.DEFAULT_ALL); //设置默认的提示音，振动方式，光</span><br><span class="line">builder.setAutoCancel(true);//点击通知后通知是否消失</span><br><span class="line">              builder.setWhen(System.currentTimeMillis())//设置通知的时间</span><br><span class="line"></span><br><span class="line">//设置通知播放音频，指定路径下的音频</span><br><span class="line">builder.setSound(Uri.fromFile(new File(&quot;音频路径&quot;)));</span><br><span class="line">//设置通知振动：下标为偶数表示静止时长，奇数为振动时长，单位为毫秒</span><br><span class="line">//需在注册地方声明权限:</span><br><span class="line">              //&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;</span><br><span class="line">long[] vibrates= &#123;0,1000,1000,1000&#125;;//此时立即振动，然后静止一秒，再振动一次</span><br><span class="line">builder.setVibrate(vibrates);</span><br><span class="line"></span><br><span class="line">//设置通知响应的事件Activity,PendingIntent可以理解为延迟的Intent</span><br><span class="line">Intent intent =new Intent (this,NotificationLayout.class);</span><br><span class="line">PendingIntent pendingIntent =PendingIntent.getActivity(this, 0, intent,0);</span><br><span class="line">builder.setContentIntent(pendingIntent);</span><br><span class="line"></span><br><span class="line">//构建一条通知Notification</span><br><span class="line">Notification notification=builder.build();</span><br></pre></td></tr></table></figure>

<p> Notification:通知类, 通过Notification.Builder的build()方法获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builder.build():构建一个Notification</span><br></pre></td></tr></table></figure>

<p> 完整例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void onClick(View v) &#123;</span><br><span class="line">	switch(v.getId()) &#123;</span><br><span class="line">	case R.id.sendNotice:</span><br><span class="line">		NotificationManager manager=            </span><br><span class="line">                 (NotificationManager)getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">		Notification.Builder builder=new Notification.Builder(this);</span><br><span class="line">		builder.setSmallIcon(R.drawable.ic_launcher); //设置图标</span><br><span class="line">		builder.setTicker(&quot;小红给你发来了一条信息&quot;);	  //显示最先在顶部收到的通知 </span><br><span class="line">		builder.setContentTitle(&quot;通知&quot;); 	//设置标题</span><br><span class="line">		builder.setContentText(&quot;点击查看详细内容&quot;); //消息内容</span><br><span class="line">		builder.setWhen(System.currentTimeMillis()); //发送时间</span><br><span class="line">		builder.setDefaults(Notification.DEFAULT_ALL); //设置默认的提示音振动方式灯光</span><br><span class="line">		builder.setAutoCancel(true);//打开程序后图标消失</span><br><span class="line">		//设置通知播放音频，指定路径下的音频</span><br><span class="line">		builder.setSound(Uri.fromFile(new </span><br><span class="line">                             File(&quot;/system/media/audio/ringtones/Basic_tone.ogg&quot;)));</span><br><span class="line">		//设置通知振动：下标为偶数表示静止时长，奇数为振动时长，单位为毫秒</span><br><span class="line">		//(需在注册地方声明权限:</span><br><span class="line">                       //&lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt;)</span><br><span class="line">		long[] vibrates= &#123;0,1000,1000,1000&#125;;//此时立即振动，然后静止一秒，再振动一次</span><br><span class="line">		builder.setVibrate(vibrates);</span><br><span class="line">		</span><br><span class="line">		//设置通知响应的事件Activity,PendingIntent可以理解为延迟的Intent</span><br><span class="line">		Intent intent =new Intent (this,NotificationLayout.class);</span><br><span class="line">		PendingIntent pendingIntent =PendingIntent.getActivity(this, 0, intent,0);</span><br><span class="line">		builder.setContentIntent(pendingIntent);</span><br><span class="line">		</span><br><span class="line">		Notification notification=builder.build();</span><br><span class="line">		manager.notify(1,notification);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="二、短信"><a href="#二、短信" class="headerlink" title="二、短信"></a>二、短信</h3><p> 发送短信和接收短信涉及权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     &lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot; /&gt;</span><br><span class="line">    &lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p> 接收短信：当系统收到短信时会自动发送广播”android.provider.Telephony.SMS_RECEIVED”</p>
<p> 1、自定义广播接收器类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MessageReceiver extends BroadcastReceiver&#123;</span><br><span class="line">	//接收到系统短信广播进行的操作</span><br><span class="line">	@Override</span><br><span class="line">	public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">		Bundle bundle=intent.getExtras();</span><br><span class="line">		Object[] pdus=(Object[])bundle.get(&quot;pdus&quot;);	//提取短信消息</span><br><span class="line">		SmsMessage[] message=new SmsMessage[pdus.length];</span><br><span class="line">                String format = intent.getStringExtra(&quot;format&quot;);</span><br><span class="line">		for(int i=0;i&lt;message.length;i++) &#123;</span><br><span class="line">			message[i]=SmsMessage.createFromPdu((byte[])pdus[i],format);</span><br><span class="line">		&#125;</span><br><span class="line">		String address=message[0].getOriginatingAddress();//获取发送方号码</span><br><span class="line">		String fullMessage=&quot;&quot;;</span><br><span class="line">		for(SmsMessage body:message) &#123;</span><br><span class="line">			fullMessage+=body.getMessageBody();//获取短信内容</span><br><span class="line">		&#125;</span><br><span class="line">		sender.setText(address);</span><br><span class="line">		content.setText(fullMessage);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 2、主活动onCreate()里注册广播接收器和onDestroy()取消注册广播接收器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">		super.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		//接收短信部分</span><br><span class="line">		sender=(TextView)findViewById(R.id.sender);</span><br><span class="line">		content=(TextView)findViewById(R.id.content);</span><br><span class="line">		messageReceiver=new MessageReceiver();</span><br><span class="line">		intentfilter=new IntentFilter();</span><br><span class="line">		intentfilter.addAction(&quot;android.provider.Telephony.SMS_RECEIVED&quot;);</span><br><span class="line">		registerReceiver(messageReceiver, intentfilter);</span><br><span class="line">    &#125;</span><br><span class="line">public void onDestroy() &#123;</span><br><span class="line">		super.onDestroy();</span><br><span class="line">		//取消注册接收信息的广播接收器</span><br><span class="line">		unregisterReceiver(messageReceiver);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 发送短信：在onCreate()里利用SmsManager发送短信，增加了一个广播接收器判断短信是否发出  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> class sendStatusReceiver extends BroadcastReceiver&#123;</span><br><span class="line">		//接收发送广播状态的广播，进行判断</span><br><span class="line">		@Override</span><br><span class="line">		public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">			if(this.getResultCode()==RESULT_OK) &#123;</span><br><span class="line">				Toast.makeText(context, &quot;Send succeed&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				Toast.makeText(context, &quot;Send failed&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        //发送短信部分</span><br><span class="line">        to=(EditText)findViewById(R.id.to);</span><br><span class="line">        msgInput=(EditText)findViewById(R.id.input);</span><br><span class="line">        send=(Button)findViewById(R.id.send);</span><br><span class="line">        intentfilter=new IntentFilter();</span><br><span class="line">        intentfilter.addAction(&quot;SENT_SMS_ACTION&quot;);</span><br><span class="line">        sendStatusReceiver=new sendStatusReceiver();</span><br><span class="line">        registerReceiver(sendStatusReceiver,intentfilter);</span><br><span class="line">        send.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                SmsManager smsManager=SmsManager.getDefault();</span><br><span class="line">                Intent sendIntent=new Intent(&quot;SENT_SMS_ACTION&quot;);</span><br><span class="line">                PendingIntent pi=PendingIntent.getBroadcast(MainActivity.this, 0,     </span><br><span class="line">                 sendIntent, 0);</span><br><span class="line">                smsManager.sendTextMessage(to.getText().toString(), null, </span><br><span class="line">                   msgInput.getText().toString(),pi, null);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> public void onDestroy() &#123;</span><br><span class="line">	super.onDestroy();</span><br><span class="line">	//取消注册接收发送信息状态变化的广播</span><br><span class="line">	unregisterReceiver(sendStatusReceiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="三、打开相机和打开相册：代码都有注释直接看代码"><a href="#三、打开相机和打开相册：代码都有注释直接看代码" class="headerlink" title="三、打开相机和打开相册：代码都有注释直接看代码"></a>三、打开相机和打开相册：代码都有注释直接看代码</h3><p> 需要读权限  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p> 不需要写权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p> 布局文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:id=&quot;@+id/LinearLayout1&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot;</span><br><span class="line">    android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot;</span><br><span class="line">    android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot;</span><br><span class="line">    android:paddingTop=&quot;@dimen/activity_vertical_margin&quot;</span><br><span class="line">    tools:context=&quot;com.example.mediatest.MainActivity&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/choose_photo&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;Choose photo&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=&quot;@+id/take_photo&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;Take photo&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/picture&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_gravity=&quot;center_horizontal&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>

<p> 对应活动代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"> public class MainActivity extends Activity &#123;</span><br><span class="line">	private Button takePhoto;</span><br><span class="line">	private Button choosePhoto;</span><br><span class="line">	private ImageView picture;</span><br><span class="line">	private Uri imageUri;</span><br><span class="line">	@Override</span><br><span class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">		super.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		takePhoto=(Button) findViewById(R.id.take_photo);</span><br><span class="line">		picture = (ImageView) findViewById(R.id.picture);</span><br><span class="line">		takePhoto.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void onClick(View v) &#123;</span><br><span class="line">				// TODO Auto-generated method stub</span><br><span class="line">				File outputPicture = new File(getExternalCacheDir(), &quot;why.jpg&quot;);</span><br><span class="line">		        if (outputPicture.exists()) &#123;//如果照片文件存在则删除</span><br><span class="line">		            outputPicture.delete();</span><br><span class="line">		        &#125;</span><br><span class="line">		        try &#123;</span><br><span class="line">		            outputPicture.createNewFile();//创建一个新照片文件</span><br><span class="line">		        &#125; catch (IOException e) &#123;</span><br><span class="line">		            e.printStackTrace();</span><br><span class="line">		        &#125;</span><br><span class="line">		        //&quot;android.media.action.IMAGE_CAPTURE&quot;用来隐式启动活动来启动相机</span><br><span class="line">		        imageUri = Uri.fromFile(outputPicture);//将文件解析成Uri</span><br><span class="line">		        Intent intent = new Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;);</span><br><span class="line">		        intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);</span><br><span class="line">		        startActivityForResult(intent, 1);//启动相机程序，并返回onActivityResult()方法</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		choosePhoto=(Button)findViewById(R.id.choose_photo);</span><br><span class="line">		choosePhoto.setOnClickListener(new OnClickListener() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void onClick(View v) &#123;</span><br><span class="line">				//将活</span><br><span class="line">				Intent intent=new Intent(&quot;android.intent.action.GET_CONTENT&quot;);</span><br><span class="line">				intent.setType(&quot;image/*&quot;);	//设置启动类型为照片，此时结果为3对应活动打开相册</span><br><span class="line">				startActivityForResult(intent,3);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">    protected void onActivityResult(int requestCode, int result, Intent data) &#123;</span><br><span class="line">        switch (requestCode) &#123;</span><br><span class="line">    		//裁剪照片</span><br><span class="line">            case 1:</span><br><span class="line">                if(result==RESULT_OK) &#123;</span><br><span class="line">                	Intent intent=new Intent(&quot;com.android.camera.action.CROP&quot;);</span><br><span class="line">                	//Data是指储存的数据（即当前照片的Uri）</span><br><span class="line">                	//Type是启动的类型：目前为照片（一般在需要裁剪照片和启动相机时使用）</span><br><span class="line">                	intent.setDataAndType(imageUri, &quot;image/*&quot;);</span><br><span class="line">                	intent.putExtra(&quot;scale&quot;, true);</span><br><span class="line">                	intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);</span><br><span class="line">                	startActivityForResult(intent,2);</span><br><span class="line">                &#125;</span><br><span class="line">            //压缩照片并显示</span><br><span class="line">            case 2:</span><br><span class="line">            	if (result == RESULT_OK) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                    	//获取图片</span><br><span class="line">                        Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(imageUri));</span><br><span class="line">                        //压缩图片在手机存储空间的内存  </span><br><span class="line">                        ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">                        bitmap.compress(Bitmap.CompressFormat.JPEG, 80, out);//80指保留80品质，压缩20品质</span><br><span class="line">                        </span><br><span class="line">                        //显示照片</span><br><span class="line">                        picture.setImageBitmap(bitmap);</span><br><span class="line"></span><br><span class="line">                    &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            //打开相册</span><br><span class="line">            case 3:</span><br><span class="line">            	if (result == RESULT_OK) &#123;</span><br><span class="line">            		//必须重写handleImageOnKitKat(Intent)和handleImageBeforeKitKat(Intent)方法</span><br><span class="line">	            	if(Build.VERSION.SDK_INT&gt;=19) &#123;</span><br><span class="line">	                    //4.4（API 19）以上版本实现打开相册</span><br><span class="line">	                    handleImageOnKitKat(data);</span><br><span class="line">	            	&#125;</span><br><span class="line">	            	else &#123;</span><br><span class="line">	            		//4.4以下版本实现打开相册</span><br><span class="line">	            		handleImageBeforeKitKat(data);</span><br><span class="line">	            	&#125;</span><br><span class="line">            	&#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void handleImageBeforeKitKat(Intent data) &#123;</span><br><span class="line">		Uri uri=data.getData();</span><br><span class="line">		String imagePath=getImagePath(uri,null);</span><br><span class="line">		showImage(imagePath);</span><br><span class="line">	&#125;</span><br><span class="line">	@TargetApi(Build.VERSION_CODES.KITKAT)</span><br><span class="line">	@SuppressLint(&quot;NewApi&quot;)</span><br><span class="line">	private void handleImageOnKitKat(Intent data) &#123;</span><br><span class="line">        //获取资源定位符</span><br><span class="line">        Uri uri = data.getData();</span><br><span class="line">        String imagePath=getImagePath(uri);</span><br><span class="line">        showImage(imagePath);</span><br><span class="line">    &#125;</span><br><span class="line">	//解析Uri返回图片路径</span><br><span class="line">    @SuppressLint(&quot;NewApi&quot;)</span><br><span class="line">	private String getImagePath(Uri uri) &#123;</span><br><span class="line">    	//选择图片路径</span><br><span class="line">        String imagePath = null;</span><br><span class="line">        if (DocumentsContract.isDocumentUri(this, uri)) &#123;</span><br><span class="line">            String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">            if (&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority())) &#123;</span><br><span class="line">                String id = docId.split(&quot;:&quot;)[1];</span><br><span class="line">                String selection = MediaStore.Images.Media._ID + &quot;=&quot; + id;</span><br><span class="line">                imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);</span><br><span class="line">            &#125; else if (&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority())) &#123;</span><br><span class="line">                Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(docId));</span><br><span class="line">                imagePath = getImagePath(contentUri, null);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">            imagePath = getImagePath(uri, null);</span><br><span class="line">        &#125; else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">            imagePath = uri.getPath();</span><br><span class="line">        &#125;</span><br><span class="line">		return imagePath;</span><br><span class="line">    &#125;</span><br><span class="line">    //子方法：根据Uri和selection返回图片路径</span><br><span class="line">    private String getImagePath(Uri externalContentUri, String selection) &#123;</span><br><span class="line">        String path = null;</span><br><span class="line">        Cursor cursor = getContentResolver().query(externalContentUri, null, selection, null, null);</span><br><span class="line">        if (cursor != null) &#123;</span><br><span class="line">            if (cursor.moveToFirst()) &#123;</span><br><span class="line">                path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));</span><br><span class="line">            &#125;</span><br><span class="line">            cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line">    //根据图片路径显示图片</span><br><span class="line">    private void showImage(String imagePath) &#123;</span><br><span class="line">        if (imagePath != null) &#123;</span><br><span class="line">            Bitmap bitmap = BitmapFactory.decodeFile(imagePath);</span><br><span class="line">            /*</span><br><span class="line">               setlmageBitmap(Bitmap bm)：使用 Bitmap 位图设置该 ImageView 显示的图片。</span><br><span class="line"></span><br><span class="line">			   setlmageDrawable(Drawable drawable)：使用 Drawable 对象设置该 ImageView 显示的图片。</span><br><span class="line"></span><br><span class="line">			   setlmageResource(int resld)：使用图片资源ID设置该ImageView显示的图片。</span><br><span class="line"></span><br><span class="line">			   setlmageURI(Uri uri)：使用图片的URI设置该ImageView显示的图片。</span><br><span class="line">             */</span><br><span class="line">            picture.setImageBitmap(bitmap);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Toast.makeText(this, &quot;没有找到对应图片&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="四、播放音频和视频"><a href="#四、播放音频和视频" class="headerlink" title="四、播放音频和视频"></a>四、播放音频和视频</h3><p> 补充知识：</p>
<p> 1、需要读取权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p> 2、获取系统内存根目录位置方法和SD卡根目录位置方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> //内存根目录获取方法：Environment.getExternalStorageDirectory()</span><br><span class="line"></span><br><span class="line">//获取SD卡根路径方法：</span><br><span class="line">public static String getSDPath(Context context) &#123;  </span><br><span class="line"></span><br><span class="line">      StorageManager mStorageManager = (StorageManager)</span><br><span class="line">                context.getSystemService(Context.STORAGE_SERVICE);</span><br><span class="line">        Class&lt;?&gt; storageVolumeClazz = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            storageVolumeClazz = Class.forName(&quot;android.os.storage.StorageVolume&quot;);</span><br><span class="line">            Method getVolumeList = mStorageManager.getClass().getMethod(&quot;getVolumeList&quot;);</span><br><span class="line">            Method getPath = storageVolumeClazz.getMethod(&quot;getPath&quot;);</span><br><span class="line">            Method isRemovable = storageVolumeClazz.getMethod(&quot;isRemovable&quot;);</span><br><span class="line">            Object result = getVolumeList.invoke(mStorageManager);</span><br><span class="line">            final int length = Array.getLength(result);</span><br><span class="line">            for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">                Object storageVolumeElement = Array.get(result, i);</span><br><span class="line">                String path = (String) getPath.invoke(storageVolumeElement);</span><br><span class="line">                boolean removable = (Boolean) isRemovable.invoke(storageVolumeElement);</span><br><span class="line">                if (removable) &#123;</span><br><span class="line">                    return path;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 1、播放音频：使用MediaPlayer类</p>
<p> MediaPlayer类有以下方法：</p>
<p> setDataSource():设置播放音频文件位置</p>
<p> prepare():在开始播放前调用此方法完成准备工作</p>
<p> start():开始或继续播放音频</p>
<p> pause():暂停播放音频</p>
<p> reset():将MediaPlayer对象重置到刚刚创建状态，修改音频文件前需要调用该方法即调用setDataSource()需要</p>
<p> 调用该方法。</p>
<p> seekTo():从指定位置开始播放音频</p>
<p> stop():停止播放音频</p>
<p> release():释放掉与MediaPlayer对象相关资源</p>
<p> isPlaying():判断是否正在播放音频</p>
<p> getDuration():获取载入的音频文件时长</p>
<p> getCurrentPosition()：获取当前进度时长</p>
<p> setOnCompletionListener():音频是否结束的监听事件</p>
<p> 非结束性停止音乐（即下次还能播放）：应先调用seekTo(0)再调用pause()</p>
<p> 结束性停止音乐（下次需要调用prepare()才能播放）：直接调用stop()</p>
<p> 2、播放视频：使用VideoView类</p>
<p> VideoView类有以下方法：</p>
<p> setVideoPath():设置视频文件位置</p>
<p> start():开始或继续播放视频</p>
<p> pause():暂停播放视频</p>
<p> resume():将视频从头开始播放</p>
<p> seekTo():从指定位置开始播放视频</p>
<p> isPlaying():判断是否正在播放视频</p>
<p> getDuration():获取载入的视频文件时长</p>
<p> 播放音频完整代码演示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"> public class MusicActivity extends Activity implements OnClickListener&#123;</span><br><span class="line">	private Button play;</span><br><span class="line">	private Button pause;</span><br><span class="line">	private Button stop;</span><br><span class="line">	private MediaPlayer mediaPlayer=new MediaPlayer();</span><br><span class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">		super.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.music);</span><br><span class="line">		play=(Button)findViewById(R.id.play);</span><br><span class="line">		pause=(Button)findViewById(R.id.pause);</span><br><span class="line">		stop=(Button)findViewById(R.id.stop);</span><br><span class="line">		play.setOnClickListener(this);</span><br><span class="line">		pause.setOnClickListener(this);</span><br><span class="line">		stop.setOnClickListener(this);</span><br><span class="line">		initMediaPlayer();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取SD卡根路径方法：</span><br><span class="line">public static String getSDPath(Context context) &#123;  </span><br><span class="line"></span><br><span class="line">      StorageManager mStorageManager = (StorageManager) context.getSystemService(Context.STORAGE_SERVICE);</span><br><span class="line">        Class&lt;?&gt; storageVolumeClazz = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            storageVolumeClazz = Class.forName(&quot;android.os.storage.StorageVolume&quot;);</span><br><span class="line">            Method getVolumeList = mStorageManager.getClass().getMethod(&quot;getVolumeList&quot;);</span><br><span class="line">            Method getPath = storageVolumeClazz.getMethod(&quot;getPath&quot;);</span><br><span class="line">            Method isRemovable = storageVolumeClazz.getMethod(&quot;isRemovable&quot;);</span><br><span class="line">            Object result = getVolumeList.invoke(mStorageManager);</span><br><span class="line">            final int length = Array.getLength(result);</span><br><span class="line">            for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="line">                Object storageVolumeElement = Array.get(result, i);</span><br><span class="line">                String path = (String) getPath.invoke(storageVolumeElement);</span><br><span class="line">                boolean removable = (Boolean) isRemovable.invoke(storageVolumeElement);</span><br><span class="line">                if (removable) &#123;</span><br><span class="line">                    return path;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void onClick(View v) &#123;</span><br><span class="line">		switch(v.getId()) &#123;</span><br><span class="line">		case R.id.play:</span><br><span class="line">			if(!mediaPlayer.isPlaying()) &#123;</span><br><span class="line">				mediaPlayer.start();</span><br><span class="line">			&#125;break;</span><br><span class="line">		case R.id.pause:</span><br><span class="line">			if(mediaPlayer.isPlaying()) &#123;</span><br><span class="line">				mediaPlayer.pause();</span><br><span class="line">			&#125;break;</span><br><span class="line">		case R.id.stop:</span><br><span class="line">			if(mediaPlayer.isPlaying()) &#123;</span><br><span class="line">				mediaPlayer.reset();</span><br><span class="line">				initMediaPlayer();</span><br><span class="line">			&#125;break;</span><br><span class="line">		default:break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public void onDestroy() &#123;</span><br><span class="line">		super.onDestroy();</span><br><span class="line">		if(mediaPlayer!=null) &#123;</span><br><span class="line">			mediaPlayer.stop();</span><br><span class="line">			mediaPlayer.release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//初始化音频文件方法：设置音频位置，完成准备工作</span><br><span class="line">	private void initMediaPlayer() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			File file=new File(getSDPath(this),&quot;aiying.mp3&quot;);</span><br><span class="line">			mediaPlayer.setDataSource(file.getPath());</span><br><span class="line">			mediaPlayer.prepare();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 播放视频完整代码演示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"> public class VedioActivity extends Activity implements OnClickListener&#123;</span><br><span class="line">	private VideoView videoView;</span><br><span class="line">	private Button play;</span><br><span class="line">	private Button pause;</span><br><span class="line">	private Button replay;</span><br><span class="line">	</span><br><span class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">		super.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.vedio);</span><br><span class="line">		videoView=(VideoView)findViewById(R.id.videoView1);</span><br><span class="line">		play=(Button)findViewById(R.id.play_vieo);</span><br><span class="line">		pause=(Button)findViewById(R.id.pause_vieo);</span><br><span class="line">		replay=(Button)findViewById(R.id.replay);</span><br><span class="line">		play.setOnClickListener(this);</span><br><span class="line">		pause.setOnClickListener(this);</span><br><span class="line">		replay.setOnClickListener(this);</span><br><span class="line">		initVideoPath();</span><br><span class="line">	&#125;</span><br><span class="line">	private void initVideoPath() &#123;</span><br><span class="line">		File file=new File(Environment.getExternalStorageDirectory(),&quot;tiao.mp4&quot;);</span><br><span class="line">		videoView.setVideoPath(file.getPath());</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void onClick(View v) &#123;</span><br><span class="line">		switch(v.getId()) &#123;</span><br><span class="line">		case R.id.play_vieo:</span><br><span class="line">			if(!videoView.isPlaying()) &#123;</span><br><span class="line">				videoView.start();</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		case R.id.pause_vieo:</span><br><span class="line">			if(videoView.isPlaying()) &#123;</span><br><span class="line">				videoView.pause();</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		case R.id.replay:</span><br><span class="line">			if(videoView.isPlaying()) &#123;</span><br><span class="line">				videoView.resume();</span><br><span class="line">			&#125;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public void onDestroy() &#123;</span><br><span class="line">		super.onDestroy();</span><br><span class="line">		if(videoView!=null) &#123;</span><br><span class="line">			videoView.suspend();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrqlyn.github.io/2018/07/20/Android/Android里的多媒体/" data-id="ckjzjncj7007z0gtphmdq15o2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android的广播接收器BroadcastReceiver" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/13/Android/Android的广播接收器BroadcastReceiver/" class="article-date">
  <time datetime="2018-07-12T16:56:24.000Z" itemprop="datePublished">2018-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/13/Android/Android的广播接收器BroadcastReceiver/">Android的广播接收器BroadcastReceiver</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 版权声明：转载请说明去处，文章仅供学习参考 <a href="https://blog.csdn.net/qq_38487155/article/details/81024098" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/81024098</a>   </p>
<h3 id="注意-广播的注册最好不要在监听方法内，容易造成onReceiver-方法调用多次"><a href="#注意-广播的注册最好不要在监听方法内，容易造成onReceiver-方法调用多次" class="headerlink" title="注意:广播的注册最好不要在监听方法内，容易造成onReceiver()方法调用多次"></a>注意:广播的注册最好不要在监听方法内，容易造成onReceiver()方法调用多次</h3><p> 一、广播分为<strong>标准广播</strong>，<strong>有序广播，</strong>本地广播****。Android内置了很多系统广播，我们可以监听这些广播来得到系统信息，如开机完成后的广播，电池电量变化广播等等。</p>
<p> <strong>标准广播：系统内广播，任何应用几乎同时收到</strong></p>
<p> ** 有序广播（一般静态注册）：系统内广播，应用按优先级分先后<strong>收到，先收到的广播接收器可切断该广播继续往下传播**</strong></p>
<p> ** 本地广播（只能动态注册）：应用内广播，只能在应用内传播，安全性高，推荐使用**</p>
<p> 二、广播的俩种注册方式： 静态注册，动态注册，注册后必须在onDestroy()里取消注册广播接收器</p>
<p> 不管是动态注册还是静态注册，若涉及到系统关键信息都需要在XML注册文件添加权限</p>
<p> 如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//监听开机广播权限</span><br><span class="line"></span><br><span class="line">        &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        对应的系统广播：android.intent.action.BOOT_COMPLETED</span><br><span class="line"></span><br><span class="line">        //查询系统网络状态权限</span><br><span class="line"></span><br><span class="line">        &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;      </span><br><span class="line"></span><br><span class="line">        对应的系统广播：android.net.conn.CONNECTIVITY_CHANGE</span><br></pre></td></tr></table></figure>

<p> <strong>静态注册：在XML注册文件里注册广播接收器和发送的广播，后定义广播接收类继承于BroadcastReceiver,重写</strong></p>
<p> ** onReceive(Context context, Intent intent)**</p>
<p> 格式： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">          &lt;receiver</span><br><span class="line">            android:name=&quot;.广播接收器类名&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;自定义广播或系统广播&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">         &lt;/receiver&gt;</span><br><span class="line"></span><br><span class="line">        public class MyBroadcastReceiver extends BroadcastReceiver &#123;</span><br><span class="line">                public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">                        Toast.makeText(context, &quot;接收到标准广播&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">                        abortBroadcast();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p> ** 动态注册：直接在Activity类里调用registerReceiver(BroadcastReceive,IntentFilter)方法发送广播，后定义广播接收**</p>
<p> ** 类继承于BroadcastReceiver,重写onReceive(Context context,Intent intent)**</p>
<p> Activity补充方法 ： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> registerReceiver(BroadcastReceive,IntentFilter)：注册广播接收器</span><br><span class="line"></span><br><span class="line">unregisterReceiver( BroadcastReceive)：取消注册广播接收器</span><br><span class="line"></span><br><span class="line">sendBroadcast(Intent):发送标准广播</span><br><span class="line"></span><br><span class="line">sendOrderedBroadcast(Intent,null):发送有序广播，有序广播在intent-filter标签的android:priority    </span><br><span class="line">                                  属性设置优先级，采用静态注册方式。</span><br><span class="line"></span><br><span class="line">abortBroadcast():在onReceive()里调用，用来截断有序广播</span><br></pre></td></tr></table></figure>

<p> Intent补充知识： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> ​</span><br><span class="line">Intent(String):String为被启动活动的XML文件里的&lt;intent-filter&gt;里的&lt;action&gt;里的android:name属性</span><br><span class="line">值，在发送广播时String为系统广播或自定义广播，也就是&lt;receiver&gt;里的&lt;intent-filter&gt;里的&lt;action&gt; 里</span><br><span class="line">的android:name属性值</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure>

<p> IntentFilter类：通过Intent的 <action>标签的android:name属性过滤掉不对应的广播</action></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    方法：addAction(String):String为系统广播或自定义广播</span><br></pre></td></tr></table></figure>




<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   动态提醒网络变化例子(记得添加权限和在Activity里注册广播接收器)：</span><br><span class="line"></span><br><span class="line">public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line"></span><br><span class="line">           Connectivity ManagerconnctivityManager=</span><br><span class="line"></span><br><span class="line">                     (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line"></span><br><span class="line">           NetworkInfo networkInfo=connctivityManager.getActiveNetworkInfo();</span><br><span class="line">           if(networkInfo!=null&amp;&amp;networkInfo.isAvailable()) &#123;</span><br><span class="line">               Toast.makeText(context, &quot;网络可用&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">                Toast.makeText(context, &quot;网络不可用&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">           &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 三、本地广播发送<strong>(接收不到系统广播,即接收不到标准广播和有序广播，只能接收自己发送的自定义本地广播)</strong></p>
<p> ** 1、 需要导入android-support-v4.jar包**</p>
<p> Eclipse导入方法：<br> Project &gt;&gt; Properties &gt;&gt; Java Build Path &gt;&gt; Libraries &gt;&gt; Add External JARs<br> 找到之前下载好的android-support-v4.jar，打开后可以看到已经添加进去列表中了，此时还需要点击 Order and Export，勾 选android-support-v4.jar 这一项，然后点击OK即可。<br> 此时回到代码界面，按快捷键ctrl + shift + O即可自动导入LocalBroadcastManager。<br> 也可以手动导入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import android.support.v4.content.LocalBroadcastManager;</span><br></pre></td></tr></table></figure>

<p> 完成后LocalBroadcastManager 不再报错，ctrl + S保存并刷新MainActivity.java。 </p>
<p> 程序即可正常运行。</p>
<p> ** 2、与动态注册一样接收使用IntentFilter类和自定义广播接收类接收广播，不同点在于注册广播，发送广播，取消注册广播 都使用LocalReceiverManager类，不使用Activity类，但仍需写在Activity里.** </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  LocalBroadcastManager类用来发送广播有以下方法：</span><br><span class="line"></span><br><span class="line">        LocalBroadcastManager.getInstance(this):静态方法，构建一个LocalBroadcastManager类实例</span><br><span class="line"></span><br><span class="line">        registerReceiver(BroadcastReceive,IntentFilter)：注册广播接收器</span><br><span class="line"></span><br><span class="line">        unregisterReceiver( BroadcastReceive)：取消注册广播接收器</span><br><span class="line"></span><br><span class="line">        sendBroadcast(Intent):发送标准广播</span><br></pre></td></tr></table></figure>





      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrqlyn.github.io/2018/07/13/Android/Android的广播接收器BroadcastReceiver/" data-id="ckjzjncb9000j0gtpt3bz4txz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android的基类Context和View" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/12/Android/Android的基类Context和View/" class="article-date">
  <time datetime="2018-07-12T15:28:56.000Z" itemprop="datePublished">2018-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/12/Android/Android的基类Context和View/">Android的基类Context和View</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 版权声明：转载请说明去处，文章仅供学习参考 <a href="https://blog.csdn.net/qq_38487155/article/details/81024056" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/81024056</a><br>   Context：抽象类，是活动Activity、服务Service、应用Application的基类，context几乎包含了所有你能想到的，一个Android程序需要的资源和操作，Context自己就像一个App一样，启动Activity、Service，发送Broadcast，拿到assets下的资源，获取SharedPreferences，show一个Dialog，无所不能。</p>
<p>View：所有可见UI控件，布局的基类</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrqlyn.github.io/2018/07/12/Android/Android的基类Context和View/" data-id="ckjzjnc9r000a0gtpop0iziqo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android里的前端界面" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/12/Android/Android里的前端界面/" class="article-date">
  <time datetime="2018-07-12T07:55:55.000Z" itemprop="datePublished">2018-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/12/Android/Android里的前端界面/">Android里的前端界面</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 版权声明：转载请说明去处，文章仅供学习参考 <a href="https://blog.csdn.net/qq_38487155/article/details/81011301" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/81011301</a><br>   如果说活动是每个界面的后台逻辑，Android里的前端界面就是res里的layout的XML文件。</p>
<p> <strong>目录</strong></p>
<p> <a href="#%E4%B8%80%E3%80%81%E6%8E%A7%E4%BB%B6">一、控件</a></p>
<p> <a href="#Button%3A%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6">Button:按钮控件</a></p>
<p> <a href="#TextView%3A%E6%96%87%E6%9C%AC%E6%8E%A7%E4%BB%B6%EF%BC%8C%E7%94%A8%E6%9D%A5%E6%98%BE%E7%A4%BA%E6%96%87%E6%9C%AC">TextView:文本控件，用来显示文本</a></p>
<p> <a href="#EditText%3A%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%EF%BC%88%E7%BC%96%E8%BE%91%EF%BC%89%E6%A1%86">EditText:文本输入（编辑）框</a></p>
<p> <a href="#ImageView%3A%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6">ImageView:显示图片控件</a></p>
<p> <a href="#ProgressBar%3A%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E8%BF%9B%E5%BA%A6%E6%9D%A1">ProgressBar:加载数据进度条</a></p>
<p> <a href="#ProgressDialog%3A%E8%BF%9B%E5%BA%A6%E6%9D%A1%E5%AF%B9%E8%AF%9D%E6%A1%86%C2%A0%20%C2%A0%C2%A0">ProgressDialog:进度条对话框 </a></p>
<p> <a href="#%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89ListView%3A%E5%88%97%E8%A1%A8%E6%8E%A7%E4%BB%B6%2C%E4%B8%8D%E5%90%8C%E4%BA%8E%E4%B8%8A%E9%9D%A2%E5%85%B6%E5%AE%83%E6%8E%A7%E4%BB%B6%EF%BC%8C%E6%A0%BC%E5%BC%8F%E4%B8%BA%3A%3CListView%3E%3C%2FListView%3E">（重点）ListView:列表控件,不同于上面其它控件，格式为:</a></p>
<p> <a href="#%E4%BA%8C%E3%80%81%E5%B8%83%E5%B1%80">二、布局</a></p>
<p> <a href="#%E4%B8%89%E3%80%81XML%E5%BC%95%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B8%83%E5%B1%80">三、XML引入自定义布局</a></p>
<hr>
<hr>
<h2 id="一、控件"><a href="#一、控件" class="headerlink" title="一、控件"></a>一、控件</h2><blockquote>
<p>1、每个控件都有id，长，宽，即在XML代码中都有android：id属性和android：layout_width属性和</p>
<p> android:layout_heigh属性</p>
<p> 定义id：android:id=”@+id/id名”</p>
<p> 引用id：android:od=”@id/id名”</p>
<p> android：layout_width和android:layout_heigh有俩种可选值：match_parent(与父布局大小一致)和</p>
<p> wrap_content(大小刚好包住内容)</p>
<p> 2、控件代码都是&lt;控件名 属性1、属性2、…. /&gt;，属性值都用””包含</p>
<p> 3、所有控件都有android：visibility属性</p>
<p> android:visibility：设置控件显示状态。可选值：visible(可见)，invisible(隐藏仍占用屏幕),gone(消失且不占屏幕)</p>
<p> 后台逻辑操控属性方法：</p>
<p> setVisibility():可传入View.VISIBLE、View.INVISIBLE,View.GONE</p>
<p> 4、 android:gravity:指定文字对齐方式</p>
<p> android:layout_gravity:指定控件在布局对齐方式</p>
<p> android:layout_weight:先按控件尺寸分配屏幕，再按layout_weight比例进行分配</p>
<p> 如：布局有俩个按钮，一个按钮layout_weight属性为1，另一按钮未设置该属性，则</p>
<p> 未设置按钮分配完基本尺寸后，剩余空间都为另一个按钮所占，此时比例为1/1.</p>
<p> 若设置了为1，则俩按钮平分布局空间</p>
<p> android:weightSum:设置layout_weight的总比例值，一般在父布局（即上一层控件）中设置</p>
</blockquote>
<h3 id="Button-按钮控件"><a href="#Button-按钮控件" class="headerlink" title="Button:按钮控件"></a>Button:按钮控件</h3><p> XML属性可自行查询文档，这里主要讲后台逻辑部分</p>
<p> 当获取到布局文件中的元素(通过Button,findViewById(R.id.id名))后，按钮的触发事件添加方式有俩钟。</p>
<blockquote>
<p>第一种：单个按钮时使用，直接调用。如：</p>
<p> button.setOnClickListener(new OnClickListener(){</p>
<p> public void onClick(View v){</p>
<p> //添加触发事件逻辑</p>
<p> }</p>
<p> });</p>
<p> 第二种：多个按钮时使用</p>
<p> One：使当前类继承OnClickListener接口（implements OnClickListener）</p>
<p> Two：若有多个按钮，都设置当前类为监听类。button.setOnClickListener(this);</p>
<p> Three:在当前类重写onClick(View v)。</p>
<p> public void onClick(View v){ //View指的是点击按钮,根据不同按钮id不同设置不同触发代码</p>
<p> switch(v.getId()) {<br> case R.id.button1:Toast.makeText(this, “按钮1”, Toast.LENGTH_SHORT).show();break;<br> case R.id.button2:Toast.makeText(this, “按钮2”, Toast.LENGTH_SHORT).show();break;</p>
<p> default:break;</p>
<p> }</p>
<p> }</p>
<p> 第三种：在类里定义一个方法，然后XML文件里android:onClick属性设置为方法名</p>
</blockquote>
<h3 id="TextView-文本控件，用来显示文本"><a href="#TextView-文本控件，用来显示文本" class="headerlink" title="TextView:文本控件，用来显示文本"></a>TextView:文本控件，用来显示文本</h3><p> 有以下属性:</p>
<blockquote>
<p>android:text:显示文本内容</p>
<p> android:gravity:指定文字对齐方式(top,bttom,left,right,center),可用”|”来指定多个值，如：”center_vertical | </p>
<p> center_horizontal”来表示文字在水平和垂直方向都居中</p>
<p> android:textSize:指定文字大小，单位sp</p>
<p> android:textColor:指定文字颜色，可用16进制数或英文</p>
</blockquote>
<h3 id="EditText-文本输入（编辑）框"><a href="#EditText-文本输入（编辑）框" class="headerlink" title="EditText:文本输入（编辑）框"></a>EditText:文本输入（编辑）框</h3><p> 有以下属性：</p>
<blockquote>
<p>android:hint:设置未输入时显示内容，输入时小时</p>
<p> android:maxLines:设置输入时最大行数，避免内容过多导致控件变形</p>
<p> android:inputType:可设置为textPassword将文本框变为密码框</p>
<p> 方法:</p>
</blockquote>
<blockquote>
<p>getText().toString():获得String形式文本</p>
<p> 如：EditText editText=(EditText)findViewById(R.id.id名);</p>
<p> editText.getText().toString();</p>
</blockquote>
<h3 id="ImageView-显示图片控件"><a href="#ImageView-显示图片控件" class="headerlink" title="ImageView:显示图片控件"></a>ImageView:显示图片控件</h3><p> 属性：</p>
<blockquote>
<p>android:src:设置显示图片，如：android:src=”@drawable/图片名”</p>
<p> scaleType：让图片铺满ImageView</p>
<p> 方法：</p>
</blockquote>
<blockquote>
<p>setImageResource(R.drawable.图片名):设置显示图片</p>
</blockquote>
<h3 id="ProgressBar-加载数据进度条"><a href="#ProgressBar-加载数据进度条" class="headerlink" title="ProgressBar:加载数据进度条"></a>ProgressBar:加载数据进度条</h3><p> 属性:</p>
<blockquote>
<p>（style=”?android:attr/progressBarStyleHorizontal”）：指定成水平进度条</p>
<p> android:max:指定进度条最大值</p>
<p> 后台：</p>
<p> progressBar（进度条类）和progress（进度类）配合使用，如：</p>
<p> progress=progressBar.getProgress();</p>
<p> progress+=10;</p>
<p> progressBar.setProgress(progress);</p>
<p> AlertDialog.Builder:在当前界面弹出警告对话框</p>
<p> 后台：</p>
<p> setTitle(String):设置警告对话框标题</p>
<p> setMessage(String):设置警告对话框信息（内容）</p>
<p> setCancelable(true/false):设置警告对话框是否可取消</p>
<p> //设置确定键</p>
<p> setPositiveButton(String,new DialogInterface.OnClickListen(){</p>
<p> public void onClick(DialogInterface,int which){</p>
<p> }</p>
<p> });</p>
<p> //设置取消键</p>
<p> setNegativeButton(String,new DialogInterface.OnClickListen(){</p>
<p> public void onClick(DialogInterface,int which){</p>
<p> }</p>
<p> });</p>
<p> show():显示警告对话框</p>
</blockquote>
<h3 id="ProgressDialog-进度条对话框"><a href="#ProgressDialog-进度条对话框" class="headerlink" title="ProgressDialog:进度条对话框"></a>ProgressDialog:进度条对话框</h3><p> 后台： </p>
<blockquote>
<p>setTitle(String):设置进度条对话框标题</p>
<p> setMessage(String):设置进度条对话框信息（内容）</p>
<p> setCancelable(true/false):设置进度条对话框是否可取消</p>
<p> show():显示进度条对话框</p>
<p> dimiss():关闭对话框</p>
</blockquote>
<h3 id="（重点）ListView-列表控件-不同于上面其它控件，格式为"><a href="#（重点）ListView-列表控件-不同于上面其它控件，格式为" class="headerlink" title="（重点）ListView:列表控件,不同于上面其它控件，格式为:"></a><strong>（重点）ListView:列表控件,不同于上面其它控件，格式为:<listview></listview></strong></h3><blockquote>
<p>** Part One后台**：用到ListView类和适配器类(这里选用数组适配器类ArrayAdapter&lt;列表子项类型&gt;)</p>
<p> ListView后台代码：</p>
<p> setAdapter():传入设置的适配器</p>
<p> setOnItemClickListener(new OnItemClickListener(){</p>
<p> public void onItemClick(AdapterView&lt;?&gt; parent,int position, longid){</p>
<p> //点击子项触发事件代码….此处position为子项索引值，可用ArrayAdapter类型的适配器类的get(position)方法</p>
<p> //从子项数组取出子项类</p>
<p> }</p>
<p> });</p>
<p> ArrayAdapter&lt;列表子项类型&gt;后台代码：</p>
<p> ArrayAdapter&lt;列表子项类型&gt;(当前活动.this,列表子项布局id,列表子项数组):构造一个适配器，若此时id为</p>
<p> android.R.layout.simple_list_item_1,此时子项布局为内置布局文件，只有一个</p>
<p> TextView，子项数组应为String类型与之对应</p>
<p> ** Part Two自定义子项步骤：**</p>
<p> 1、自定义子项布局文件，在构建适配器时传入布局id</p>
<p> 2、自定义子项类（包含对应的类型变量，如 TextView对应定义String变量，图片对应int变量），同时重写子项类构造</p>
<p> 函数和对应变量的返回函数</p>
<p> 3、自定义适配器类（包含子项布局ID变量resourceId，因为后面要用）继承于ArrayAdapter&lt;自定义子项类&gt;</p>
<p> 重写构造方法：super(当前活动.this,列表子项布局id,列表子项数组)</p>
<p> resourceId=列表子项布局id;</p>
<p> 重写public View getView(int position,View cachView,ViewGroup parent):当列表滚动至屏幕包含子项调用的方法</p>
<p> Fruit fruit=getItem(position); //获得滚动进屏幕的子项类</p>
<p> View view;</p>
<p> if(cachView==null){ //缓存视图为空</p>
<p> view=LayoutInflater.from(getContext()).inflate(resourceId,null); //获得子项布局View</p>
<p> } else{</p>
<p> view=cachView;</p>
<p> } </p>
<p> //接下来就是给布局文件里的具体控件加载资源</p>
<p> //如：TextView textView=findViewById(R.id.控件id名);</p>
<p> // textView.setText(fruit.getText());…. </p>
<p> return view; //最后返回子项布局view</p>
<p> }</p>
</blockquote>
<h2 id="二、布局"><a href="#二、布局" class="headerlink" title="二、布局"></a>二、布局</h2><blockquote>
<p>LinearLayout：线性布局</p>
<p> RelativeLayout:相对布局（推荐使用，可随意放置控件布置）</p>
<p> TableLayout:表格布局</p>
<p> FrameLayout:少用</p>
</blockquote>
<h2 id="三、XML引入自定义布局"><a href="#三、XML引入自定义布局" class="headerlink" title="三、XML引入自定义布局"></a>三、XML引入自定义布局</h2><blockquote>
<p>&lt;#include layout=”@layout/布局文件名”&gt;</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrqlyn.github.io/2018/07/12/Android/Android里的前端界面/" data-id="ckjzjnci1006y0gtpv0xjnytj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android的活动Activity" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/11/Android/Android的活动Activity/" class="article-date">
  <time datetime="2018-07-11T11:01:45.000Z" itemprop="datePublished">2018-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/11/Android/Android的活动Activity/">Android的活动Activity</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 版权声明：转载请说明去处，文章仅供学习参考 <a href="https://blog.csdn.net/qq_38487155/article/details/81004729" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/81004729</a><br>   AndroidManifest.xml：所有四大组件都需要在这里注册</p>
<p> 活动（Activity类）：活动即每个界面的后台逻辑，前端界面为layout的xml文件。所有的活动都要继承于Activity类。</p>
<h3 id="一、活动的注册"><a href="#一、活动的注册" class="headerlink" title="一、活动的注册"></a>一、活动的注册</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;application</span><br><span class="line">        android:allowBackup=&quot;true&quot;</span><br><span class="line">        android:icon=&quot;@drawable/ic_launcher&quot;</span><br><span class="line">        android:label=&quot;@string/app_name&quot;</span><br><span class="line">        android:theme=&quot;@style/AppTheme&quot;&gt;</span><br><span class="line">        &lt;activity</span><br><span class="line">            android:name=&quot;.当前活动类名&quot;</span><br><span class="line">            android:label=&quot;标题栏内容&quot;</span><br><span class="line">            android:icon=&quot;引用图片名(即设置应用图标)&quot;</span><br><span class="line">            android:launchMode=&quot;启动类型&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;    //此标签可复制设置主活动</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/application&gt;</span><br></pre></td></tr></table></figure>


<h3 id="二、活动的启动类型"><a href="#二、活动的启动类型" class="headerlink" title="二、活动的启动类型"></a>二、活动的启动类型</h3><blockquote>
<p>standard(默认)：每次启动活动都创建一个新的实例</p>
<p> singleTop:当栈顶活动为该活动时不会创建新的示例</p>
<p> <strong>singleTask(推荐)：当栈里有该活动时，不会创建新的实例，将该活动之上的活动都出栈</strong></p>
<p> singleInstance:在有其它应用想使用是使用（即共享活动）</p>
<p> 创建一个单独的栈来管理活动</p>
<p> <img src="https://img-blog.csdn.net/2018071118094329?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDg3MTU1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
</blockquote>
<h3 id="三、活动类经常使用的方法"><a href="#三、活动类经常使用的方法" class="headerlink" title="三、活动类经常使用的方法"></a>三、活动类经常使用的方法</h3><blockquote>
<p>super.onCreate(Bundle):创建活动时加载临时数据</p>
<p> requestWindowFeature(Window.FEATURE_NO_TITLE):取消标题栏，必须在setContentView()前执行，不然报错</p>
<p> setContentView(R.layout.布局名):给活动加载布局</p>
<p> startActivity(Intent):通过Intent启动活动</p>
<p> startActivityForResult(Intent,int):通过Intent启动活动，int为请求码(自己设定)，被启动活动销毁后会返回数据给上一活动，</p>
<p> 上一活动会自调用onActivityResult()方法 会自动调用onActivityResult()方法</p>
<p> setResult(Result,Intent):Result为Result_OK或Result_CANCELED用来向上一活动返回处理结果，Intent用来装返回数据</p>
<p> getIntent():获取启动当前活动的Intent</p>
<p> findViewById(R.id.id名):获取在布局文件中的元素，如：控件</p>
</blockquote>
<h3 id="四、活动类可重写的方法"><a href="#四、活动类可重写的方法" class="headerlink" title="四、活动类可重写的方法"></a>四、活动类可重写的方法</h3><blockquote>
<p>** 活动的状态函数：onXXX()，如:onCreate(),重写时必须在第一行调用super.onXXX(),如：super.onCreate(Bundle);**</p>
</blockquote>
<blockquote>
<p>onActivityResult(int requestCode,int result,Intent data): requestCode为请求吗,result为Result为Result_OK或</p>
<p> Result_CANCELED,data为被启动活动返回数据</p>
<p> onSaveInstanceState(Bundle):保存临时数据，必须调用super.onSaveInstanceState(Bundle),方法在活动在回收之前调用，</p>
<p> 将数据保存至Bundle里，该Bundle即onCreate(Bundle)里的Bundle</p>
<p> onBackPressed():当手机按下Back键触发的方法，可用来解决Back键的活动之间返回数据不成功等问题</p>
</blockquote>
<h3 id="五、数据传输保存类和消息提示类（Intent-Bundle，Toast）"><a href="#五、数据传输保存类和消息提示类（Intent-Bundle，Toast）" class="headerlink" title="五、数据传输保存类和消息提示类（Intent,Bundle，Toast）"></a>五、数据传输保存类和消息提示类（Intent,Bundle，Toast）</h3><blockquote>
<p><strong>保存数据有俩个类：Intent和Bundle,消息提示类:Toast</strong></p>
<p> <strong>Intent：被用于不同组件传输数据，可用来启动活动，启动服务，发送广播等</strong></p>
</blockquote>
<p> 有以下方法：</p>
<blockquote>
<p>Intent(启动活动.this,被启动活动.class):配合startActivity(Intent)或startActivityForResult(Intent,int)作为显示启动方法</p>
<p> Intent(String):String为被启动活动的XML文件里的<intent-filter>里的<action>里的android:name属性值。</action></intent-filter></p>
<p> addCategory(String):String为除默认Category外的category，方法给Intent指定<category>里的的android:name属性值</category></p>
<p> 注意：1、当活动与Intent里的<action>里的android:name和<category>里的android:name都一致时为隐式启动</category></action></p>
<p> 活动方法</p>
<p> 2、一个Intent可以指定一个action，多个category</p>
<p> 3、android.intent.category.DEFAULT是默认category,Intent无需指定</p>
<p> putExtra(String Key,String Value):用键值对方式往Intent里放入数据</p>
<p> getXxxExtra(String Key):通过Key取出数据Value（Xxx可为String等数据类型）</p>
</blockquote>
<p> <strong>Bundle：长用来保存临时数据，super.onCreate(Bundle)和onSaveInstance(Bundle)配合使用</strong></p>
<p> 有以下方法：</p>
<blockquote>
<p>putXxx(String Key,String Value):以键值对方式往Bundle放入数据（Xxx可为String等数据类型）</p>
<p> getXxx(String Key):通过Key得到Value（Xxx可为String等数据类型</p>
<p> <strong>Toast:在屏幕底部弹出小黑框消息</strong></p>
</blockquote>
<blockquote>
<p>格式:Toast.makeText(显示活动.this,String content,Toast.LENGTH):Toast.LENGTH 可为Toast.LENGTH.LONG</p>
<p> 或Toast.LENGTH.SHORT用来设置显示时间长短</p>
<p> content为显示内容</p>
</blockquote>
<h3 id="六、活动的小技巧"><a href="#六、活动的小技巧" class="headerlink" title="六、活动的小技巧"></a>六、活动的小技巧</h3><blockquote>
<p>小技巧One: 知晓当前活动的类名<br> 1、写一个基类BaseActivity<br> 2、让所有类继承于BaseActivity<br> 3、在BaseActivity的onCreate(Bundle)方法上写入<br> Log.d(“BaseActivity”,getClass().getSimpleName());</p>
<p> 小技巧Two:瞬间退出程序<br> 1、创建活动管理类ActivityCollector<br> 2、写一个基类BaseActivity,当活动onCreate()时添加至ActivityCollector里，onDestroy()时删除该<br> 活动<br> 3、让所有类继承于BaseActivity</p>
</blockquote>
<h3 id="1、创建活动管理类ActivityCollector"><a href="#1、创建活动管理类ActivityCollector" class="headerlink" title="** 1、创建活动管理类ActivityCollector**"></a>** 1、创建活动管理类ActivityCollector**</h3><p> ** 2、写一个基类BaseActivity,当活动onCreate()时添加至ActivityCollector里，onDestroy()时删除该活动**</p>
<p> ** 3、让所有类继承于BaseActivity**</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrqlyn.github.io/2018/07/11/Android/Android的活动Activity/" data-id="ckjzjncbh000r0gtp0z956zq4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android/Android基础入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/11/Android/Android基础入门/" class="article-date">
  <time datetime="2018-07-11T09:52:21.000Z" itemprop="datePublished">2018-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/11/Android/Android基础入门/">Android基础入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 版权声明：转载请说明去处，文章仅供学习参考 <a href="https://blog.csdn.net/qq_38487155/article/details/81004629" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/81004629</a><br>   一，构建Android的开发环境，此处不表，网上很多文章</p>
<p> 二，创建的Android项目：选Android应用程序项目（第一个选4.0，第二个4.4第三个6.0）</p>
<p> 三，文件分析：</p>
<p> SRC：后端操作的地方，即放JAVA代码的地方</p>
<p> 斌：编译文件（有APK）</p>
<p> 库：放第三方的jar包，所有在库的JAR包会自动添加至构建路径上。</p>
<p> RES：放置资源文件（照片放在抽拉-HDPI下，布局放在布局下，字符串放）以键值对方式放在值下）</p>
<p> 如图1所示，取字符串俩种方式：代码用R.string键名，XML用@串/键名</p>
<p> 2，XML引用图片，字符串，布局：@绘制/图片名，@串/键名，@布局/布局名</p>
<p> 3，XML定义用：@ + D / I名</p>
<p> 安卓的的Manifest.xml：</p>
<p> projec.properties：</p>
<p> 安卓的介绍</p>
<p> 安卓的四大组件：活动，服务，广播接收器，内容</p>
<p> 活动（活动类）：可以理解为界面的业务逻辑</p>
<p> 广播接收器（广播接收器）：接收广播的类，应用程序间或应用程序内部通讯的工具类</p>
<p> 服务：后台看不见默默运行的类</p>
<p> 内容：待更新</p>
<p> 安卓的打印工具</p>
<p> 日志工具：以下打印信息等级从低到高</p>
<p> 格式：Log.d（“当前类名”，打印内容）</p>
<p> Log.v（）：打印琐碎信息</p>
<p> Log.d（）：打印调试信息</p>
<p> Log.i（）：打印重要数据信息</p>
<p> Log.w（）：打印警告信息</p>
<p> Log.e（）：打印错误信息</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrqlyn.github.io/2018/07/11/Android/Android基础入门/" data-id="ckjzjncbc000l0gtp7tk1g0fg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库/MySQL学习笔记(四)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/11/数据库/MySQL学习笔记(四)/" class="article-date">
  <time datetime="2018-07-11T09:28:59.000Z" itemprop="datePublished">2018-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/11/数据库/MySQL学习笔记(四)/">MySQL学习笔记(四)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 版权声明：转载请说明去处，文章仅供学习参考 <a href="https://blog.csdn.net/qq_38487155/article/details/79516314" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/79516314</a><br>   <strong>目录</strong></p>
<p> <a href="#%E4%B8%80%E3%80%81%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86%EF%BC%9A">一、补充知识：</a></p>
<p> <a href="#%E4%BA%8C%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%9A%E9%A1%BE%E5%90%8D%E6%80%9D%E4%B9%89%EF%BC%8C%E8%A7%A6%E5%8F%91%E5%99%A8%E5%B0%B1%E6%98%AF%E5%9C%A8%E5%AF%B9%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E6%9B%B4%E6%96%B0%EF%BC%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E6%97%B6%E4%BC%9A%E8%A7%A6%E5%8F%91%E7%9A%84%E6%93%8D%E4%BD%9C">二、触发器：顾名思义，触发器就是在对表进行插入，更新，删除操作时会触发的操作</a></p>
<hr>
<h3 id="一、补充知识："><a href="#一、补充知识：" class="headerlink" title="一、补充知识："></a>一、补充知识：</h3><p> 1.1 AUTO_INCREMENT关键字（在尾部添加，放在主键后面）：设置变量为自增变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> CREATE TABLE   test</span><br><span class="line">(</span><br><span class="line">             id int PRIMARY KEY AUTO_INCREMENT</span><br><span class="line">)AUTO_INCREMENT = 100;</span><br></pre></td></tr></table></figure>

<p> 1.2 一般情况下，MySQL的默认是以; 作为结束执行语句，与触发器中需要的分行起冲突</p>
<p> 解决办法：DELIMITER ||，可以将结束符号变成||</p>
<p> 当触发器创建后，可用DELIMITER ; 进行还原</p>
<p> 1.3 FOREIGN_KEY_CHECKS变量：用来控制外键约束，可设置为0取消外键约束，设置为1还原外键约束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> create trigger updateBookName before update on book for each row</span><br><span class="line">begin</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class="line">if(old.图书编号!=new.图书编号) then</span><br><span class="line">	update onsale set 图书编号=new.图书编号 where 图书编号=old.图书编号;</span><br><span class="line">end if;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br><span class="line">end;$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>


<h3 id="二、触发器：顾名思义，触发器就是在对表进行插入，更新，删除操作时会触发的操作"><a href="#二、触发器：顾名思义，触发器就是在对表进行插入，更新，删除操作时会触发的操作" class="headerlink" title="二、触发器：顾名思义，触发器就是在对表进行插入，更新，删除操作时会触发的操作"></a>二、触发器：顾名思义，触发器就是在对表进行插入，更新，删除操作时会触发的操作</h3><p> <strong>2.1创建触发器</strong></p>
<p> 格式：在每个行的表名触发的操作之前/之后创建触发器名</p>
<blockquote>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;  CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件</span><br><span class="line">ON 表名 FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    执行语句列表</span><br><span class="line">END</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<blockquote>
<p> 触发时间有俩种</p>
</blockquote>
<p> before：在操作前触发</p>
<p> after：在操作后触发</p>
<p> 触发事件有三种：</p>
<p> insert：insert触发进行操作，load data和replace也同样会触发操作。</p>
<p> update：update触发进行操作。</p>
<p> delete：删除触发进行操作，replace也会触发操作。</p>
<p> 注意：对于一张表来说不能有俩个触发操作同样的触发器，只能各自有一个。</p>
<p> <strong>2.2删除触发器</strong></p>
<blockquote>
<p>drop trigger 器名</p>
<p> <strong>2.3触发器的俩个对象：old对象和new对象。</strong></p>
</blockquote>
<p> 可用old和new对新纪录或旧纪录进行操作，比对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> insert触发器：会将待插入的记录写入new对象里，可在触发器里使用&quot; new.列名 &quot;调用数据</span><br><span class="line"></span><br><span class="line">delete触发器：会将待删除的记录写入old对象里，可在触发器里使用&quot; old.列名 &quot;调用数据</span><br><span class="line"></span><br><span class="line">update触发器：会将已存在旧记录写入old对象，马上更新记录写入new对象。</span><br></pre></td></tr></table></figure>



<p> 实验用的雇员数据表，数项设置为AUTO_INCREMENT自增属性，插入时自动增加。</p>
<p> //增加数列列的语句：alter table employee add column number int（1）primary key auto_increment;</p>
<p> <img src="https://img-blog.csdn.net/20180311164041395" alt></p>
<p> 可以知道当前人数有7位，假定我们设定只能存入七位职员数据，通过一个触发器inspeck判断插入前人数（数目）是否超过人数限制7位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> delimiter || </span><br><span class="line"></span><br><span class="line">create trigger t1 before insert</span><br><span class="line"></span><br><span class="line">for each row</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line">declare x int;</span><br><span class="line"></span><br><span class="line">select count(id) into x from employee;</span><br><span class="line"></span><br><span class="line">if(x &gt; = 7)then</span><br><span class="line"></span><br><span class="line">insert into bucunzai values(0); //目前的MySQL的没有抛出异常方法，设置一个语句</span><br><span class="line">                                //插入不存在的表数据抛出异常</span><br><span class="line"></span><br><span class="line">end if;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<p> 此时已知表中有六位职员，只能添加最后一位，达到触发器限制，会在添加前（之前）限制添加。</p>
<p> <img src="https://img-blog.csdn.net/20180311164614451" alt></p>
<p> 触发器可以使用的场景有很多，且具有一定逻辑性，例如：一张货物表，一张订单表，当添加一个新订单时需要检查货物数量是否达到订单要求，可以使用触发器在订单插入前检查另一表中数量。</p>
<p> 最后，删除触发器，毕竟一张表同一类型的触发器只能有一个。</p>
<p> 记得要将结束符改回来：DELIMITER;</p>
<p> <strong>相关章节：</strong></p>
<p> （一）<a href="https://blog.csdn.net/qq_38487155/article/details/79475851" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/79475851</a></p>
<p> （二）<a href="https://blog.csdn.net/qq_38487155/article/details/79488478" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/79488478</a></p>
<p> （三）<a href="https://blog.csdn.net/qq_38487155/article/details/79508140" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/79508140</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrqlyn.github.io/2018/07/11/数据库/MySQL学习笔记(四)/" data-id="ckjzjncfs00510gtp4dt6lsnf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据库/MySQL学习笔记(三)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/11/数据库/MySQL学习笔记(三)/" class="article-date">
  <time datetime="2018-07-11T09:28:52.000Z" itemprop="datePublished">2018-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/11/数据库/MySQL学习笔记(三)/">MySQL学习笔记(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 版权声明：转载请说明去处，文章仅供学习参考 <a href="https://blog.csdn.net/qq_38487155/article/details/79508140" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/79508140</a><br>   <strong>目录</strong></p>
<p> <a href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E8%A1%A8%E9%87%8C%E5%86%85%E5%AE%B9%E7%9A%84%E4%BF%AE%E6%94%B9%E5%92%8C%E5%88%A0%E9%99%A4%EF%BC%88%E6%9B%B4%E6%94%B9%EF%BC%8C%E5%88%A0%E9%99%A4%EF%BC%89">一、数据表里内容的修改和删除（更改，删除）</a></p>
<p> <a href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E8%A1%A8%E9%87%8C%E5%86%85%E5%AE%B9%E7%9A%84%E6%9B%B4%E6%96%B0%EF%BC%88%E6%9B%B4%E6%96%B0%EF%BC%89">二、数据表里内容的更新（更新）</a></p>
<p> <a href="#%E4%B8%89%E3%80%81%E7%B4%A2%E5%BC%95%E5%92%8C%E8%A7%86%E5%9B%BE">三、索引和视图</a></p>
<p> <a href="#%E5%9B%9B%E3%80%81%20%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0">四、 内置函数</a></p>
<hr>
<p>准备好一个表的员工，接下来都是对这个表进行操作</p>
<p> <img src="https://img-blog.csdn.net/2018031016064672" alt></p>
<h2 id="一、数据表里内容的修改和删除（更改，删除）"><a href="#一、数据表里内容的修改和删除（更改，删除）" class="headerlink" title="一、数据表里内容的修改和删除（更改，删除）"></a>一、数据表里内容的修改和删除（更改，删除）</h2><p> <strong>1.1增加一列数据</strong></p>
<p> <strong>格式：alter table 表名 add column 列名 数据类型（数据长度）;</strong></p>
<p> 注意：当名添加至某一固定位置时，在尾部添加之后列名1即可添加至列名1的后面，当添加至第一列时直接在尾部添加第一即可。</p>
<p> 在名字的后面增加一列数据薪水</p>
<p> alter table employee add column salary float（1）;</p>
<p> <img src="https://img-blog.csdn.net/20180310161806939" alt></p>
<p> <strong>1.2删除一列数据</strong></p>
<p> <strong>格式：alter table 表名 drop column 列名;</strong></p>
<p> 删除薪水列</p>
<p> alter table employee drop column salary;</p>
<p> <img src="https://img-blog.csdn.net/20180310161819102" alt></p>
<p> ** 1.3删除一行数据**</p>
<p> <strong>格式：delete from 表名 where 条件</strong></p>
<p> 注意：若不添加条件，则清空整张表</p>
<p> 删除最后一行玛丽的数据</p>
<p> delete from employee where name =’mary’;</p>
<p> <img src="https://img-blog.csdn.net/20180310161825976" alt></p>
<p> <strong>1.4对一列数据的重定义（一般用来重命名）</strong></p>
<p> <strong>格式：alter table 表名 change 原列名新列名数据类型（数据长度）约束;</strong></p>
<p> 注意：此时若修改了数据类型，可能会造成数据丢失。</p>
<p> 添加一列薪水（ENUM），后修改为性别</p>
<p> alter table employee add column salary int（1）;</p>
<p> alter table employee change salary sex int（1）;</p>
<p> <img src="https://img-blog.csdn.net/20180310162803161" alt></p>
<p> <strong>1.5对一列数据类型的修改</strong></p>
<p> <strong>格式：alter table 表名 modiify 列名 数据类型</strong></p>
<p> 将性别的INT型改成枚举类型</p>
<p> alter table employee modify sex enum（’男’，’女’）;</p>
<p> <img src="https://img-blog.csdn.net/20180310162812722" alt></p>
<h2 id="二、数据表里内容的更新（更新）"><a href="#二、数据表里内容的更新（更新）" class="headerlink" title="二、数据表里内容的更新（更新）"></a>二、数据表里内容的更新（更新）</h2><p> <strong>2.1更新表中某行一个或多个数据</strong></p>
<p> <strong>格式：update 表名 set 列名=’更新值’，列名=更新值……where 条件（条件用来确定哪一行，可确定多行）</strong></p>
<p> 注意：若不加条件，则会更新每一行的列数据</p>
<p> 将第一行汤姆的性别改为男，年龄改为1岁</p>
<p> 更新员工设置性别=’男’，年龄= 1，其中name =’tom’;</p>
<p> <img src="https://img-blog.csdn.net/20180310162825626" alt></p>
<h2 id="三、索引和视图"><a href="#三、索引和视图" class="headerlink" title="三、索引和视图"></a>三、索引和视图</h2><p> <strong>3.1索引：就像字典里的目录，加快查找数据速度</strong></p>
<blockquote>
<blockquote>
<ol>
<li>主键列一定要建立索引 </li>
<li>外键列可以建立索引 </li>
<li>text和二进制数据不要建立索引<br><strong>格式：create index 索引名 on 表名（列名）</strong></li>
</ol>
</blockquote>
</blockquote>
<p> 给ID加上索引</p>
<p> 在雇员（ID）上创建索引idsy;</p>
<p> <img src="https://img-blog.csdn.net/20180310193119237" alt></p>
<p> <strong>显示当前已加的索引：show indexs from 表名</strong></p>
<p> <img src="https://img-blog.csdn.net/20180310193124599" alt></p>
<p> 可以看到员工表中已经设置有索引的有编号和名称俩项。</p>
<p> <strong>删除索引：drop index 索引名 on 表名</strong></p>
<p> <strong>3.2视图的创建</strong></p>
<p> 视图：在原有表或视图的基础上，挑选需要的列数据创建的一个新表叫做视图，这个新表的数据全部来源于原有表，当原有表的</p>
<p> 数据改变时，视图的数据也会跟着改变。视图可以看做一张表，对视图数据进行更改，原有表数据也会更改。</p>
<p> <strong>格式：create view 视图名（列名，….）as select 语句 【with local / cascaded check option】</strong></p>
<p> <strong>with local check option（可不加） ：在对视图进行update、insert、delete时要保证满足select语句里的where条件</strong></p>
<p> ** 若当前视图建立在视图基础上，只检查当前视图的select语句里的where条件**</p>
<p> <strong>with cascaded check option（可不加）：在对视图进行update、insert、delete时要保证满足select语句里的where条件</strong> </p>
<p> ** 若当前视图建立在视图基础上，检查当前视图、底层视图的select语句里的where条件**</p>
<h2 id="四、-内置函数"><a href="#四、-内置函数" class="headerlink" title="四、 内置函数"></a>四、 内置函数</h2><p> 内置函数：即mysql里已有的函数，函数可以嵌套。</p>
<p> <strong>4.1数学函数</strong></p>
<blockquote>
<p>abs（x）：返回x的绝对值</p>
<p> pow（x，y）：x的y次方/幂</p>
<p> mod（x，y）：x除以y后的余数</p>
<p> sqrt（x）：x的二次方开方，求根。</p>
<p> exp（x）：e的x次方</p>
<p> ceil（x）：返回不小于x的最小整数值</p>
<p> floor（x）：返回不大于x的最大整数值</p>
<p> rand（）：返回0~1的随机数</p>
<p> pi（）：返回PI值</p>
<p> round（x）：返回离x最近的整数</p>
<p> round（x，y）：保留x小数点后y位的值，截取时需要四舍五入</p>
<p> <strong>4.2字符串函数</strong></p>
</blockquote>
<blockquote>
<p>concat（s1，s2，…）：将多个字符串连接为一个字符串</p>
<p> group_concat（列名）：将一整列数据连接成未一个字符串</p>
<p> 4.3日期和时间函数</p>
</blockquote>
<blockquote>
<p>curdate（）：返回日期，即年月日</p>
<p> curtime（）：返回时间，即时分秒</p>
<p> Now（）：返回当前日期和时间</p>
<p> year（d）：返回日期d里的年份</p>
<p> month（d）：返回日期的月份</p>
<p> dayofmonth（d）：返回日期d是本月第几天</p>
<p> hour（d）/ minute（d）/ second（d）：返回日期里的小时值，分钟值，秒值</p>
<p> datediff（d1，d2）：日期d1和日期d2相隔天数</p>
<p> adddate（d，n）：日期+n天后的日期</p>
<p> subdate（d，n）：日期-n天后的日期</p>
</blockquote>
<p> <strong>相关章节：</strong></p>
<p> （一）<a href="https://blog.csdn.net/qq_38487155/article/details/79475851" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/79475851</a></p>
<p> （二）<a href="https://blog.csdn.net/qq_38487155/article/details/79488478" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/79488478</a></p>
<p> （四）<a href="https://blog.csdn.net/qq_38487155/article/details/79516314" target="_blank" rel="noopener">https://blog.csdn.net/qq_38487155/article/details/79516314</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrqlyn.github.io/2018/07/11/数据库/MySQL学习笔记(三)/" data-id="ckjzjncfr004z0gtp8e84phm1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据库/">数据库</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/11/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/13/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java基础/">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web高阶/">Web高阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础操作/">基础操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活照片/">生活照片</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 18.57px;">Android</a> <a href="/tags/C/" style="font-size: 12.86px;">C++</a> <a href="/tags/Git/" style="font-size: 11.43px;">Git</a> <a href="/tags/Java基础/" style="font-size: 15.71px;">Java基础</a> <a href="/tags/Web/" style="font-size: 20px;">Web</a> <a href="/tags/Web高阶/" style="font-size: 18.57px;">Web高阶</a> <a href="/tags/前端/" style="font-size: 14.29px;">前端</a> <a href="/tags/基础操作/" style="font-size: 10px;">基础操作</a> <a href="/tags/数据库/" style="font-size: 15.71px;">数据库</a> <a href="/tags/数据结构与算法/" style="font-size: 17.14px;">数据结构与算法</a> <a href="/tags/生活照片/" style="font-size: 11.43px;">生活照片</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/01/16/diary/2021-1-16记/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/01/08/迟来的2020总结与2021眺望/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/01/07/diary/2021-1-7记/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/12/05/LifeRecord/">LifeRecord</a>
          </li>
        
          <li>
            <a href="/2020/12/05/上传图片测试/">上传图片测试</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Qin Lin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>