<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Java多线程代码 | シェンキンリンのブログ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="目录  创建多线程第一种方法：  创建多线程第二种方法：  多线程同步：  多线程通信：  创建多线程第一种方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 package Multiple__Thread;/* * 进程：是程序一次的">
<meta name="keywords" content="Java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程代码">
<meta property="og:url" content="https://mrqlyn.github.io/2019/07/14/java基础/Java多线程代码/index.html">
<meta property="og:site_name" content="シェンキンリンのブログ">
<meta property="og:description" content="目录  创建多线程第一种方法：  创建多线程第二种方法：  多线程同步：  多线程通信：  创建多线程第一种方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 package Multiple__Thread;/* * 进程：是程序一次的">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-07-14T06:09:54.978Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程代码">
<meta name="twitter:description" content="目录  创建多线程第一种方法：  创建多线程第二种方法：  多线程同步：  多线程通信：  创建多线程第一种方法：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 package Multiple__Thread;/* * 进程：是程序一次的">
  
    <link rel="alternate" href="/atom.xml" title="シェンキンリンのブログ" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">シェンキンリンのブログ</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Learning records of a typist</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://mrqlyn.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java基础/Java多线程代码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/14/java基础/Java多线程代码/" class="article-date">
  <time datetime="2019-07-14T02:55:05.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java多线程代码
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>目录</strong></p>
<p> <a href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9A">创建多线程第一种方法：</a></p>
<p> <a href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9A">创建多线程第二种方法：</a></p>
<p> <a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%9A">多线程同步：</a></p>
<p> <a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9A">多线程通信：</a></p>
<hr>
<h3 id="创建多线程第一种方法："><a href="#创建多线程第一种方法：" class="headerlink" title="创建多线程第一种方法："></a>创建多线程第一种方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> package Multiple__Thread;</span><br><span class="line">/*</span><br><span class="line"> * 进程：是程序一次的运行</span><br><span class="line"> * 多线程：是一个进程里的多个线程进行操作</span><br><span class="line"> * </span><br><span class="line"> * 创建的第一种方法：继承Thread类，重写run方法</span><br><span class="line"> * Thread有以下方法：</span><br><span class="line"> * </span><br><span class="line"> * start():开始线程	</span><br><span class="line"> * sleep(long millis):休眠当前正在执行线程，millis为休眠毫秒数</span><br><span class="line"> * join():老大加入(A线程中B线程调用join()方法，必须等B执行完后才能执行A线程)</span><br><span class="line"> * yield():暂停当前正在执行线程，可能又被当前线程抢占CPU，也可能被其它线程抢占CPU</span><br><span class="line"> * interrupt():从等待状态中退出</span><br><span class="line"> * isAlive():判断当前线程是否存在</span><br><span class="line"> * </span><br><span class="line"> * currentThread():返回当前线程(静态方法)</span><br><span class="line"> * setName(String):设置线程名字</span><br><span class="line"> * getName():返回线程名字</span><br><span class="line"> * </span><br><span class="line"> * setPriority(int newPriority):设置线程优先级(默认为5，最低1，最高10)</span><br><span class="line"> * getPriority():返回当前线程优先级</span><br><span class="line"> */</span><br><span class="line">//创建一个子线程，和主线程一起输出1-100的正整数</span><br><span class="line">class MyThread extends Thread&#123;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		for(int i=1;i&lt;=100;i++) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.currentThread().sleep(1000);	//执行时休眠1000毫秒</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+Thread.currentThread().getPriority()+&quot;:&quot;+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CreateWay &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		MyThread m=new MyThread();</span><br><span class="line">		//m.run();	//错误：若此时执行run()只是调用对象的run方法，不会创建一个线程</span><br><span class="line">		m.start();</span><br><span class="line">		</span><br><span class="line">		//修改主线程，子线程名称</span><br><span class="line">		m.setName(&quot;子线程&quot;);</span><br><span class="line">		Thread.currentThread().setName(&quot;========主线程&quot;);</span><br><span class="line">		if(m.isAlive()) &#123;System.out.println(&quot;子线程未执行完毕&quot;);&#125;	//判断子线程是否存在</span><br><span class="line">		//主线程 </span><br><span class="line">		Thread.currentThread().setPriority(10); 		//设置优先级后，明显主线程抢占CPU较快</span><br><span class="line">		for(int i=1;i&lt;=100;i++) &#123;</span><br><span class="line">			if(i%10==0) &#123;Thread.currentThread().yield();&#125;	//当i为10的倍数时，看看主线程子线程哪个能否抢占CPU</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+Thread.currentThread().getPriority()+&quot;:&quot;+i);</span><br><span class="line">			if(i==80) &#123;m.join();&#125;	//子线程变大佬加入，只能等大佬执行完后主线程再执行</span><br><span class="line">		&#125;</span><br><span class="line">		if(!m.isAlive()) &#123;System.out.println(&quot;子线程已执行完毕&quot;);&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="创建多线程第二种方法："><a href="#创建多线程第二种方法：" class="headerlink" title="创建多线程第二种方法："></a>创建多线程第二种方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> package Multiple__Thread;</span><br><span class="line">/*</span><br><span class="line"> * 多线程的另一方式（也是常用方式）:接口Runnable提供了run()方法,且只有run()方法</span><br><span class="line"> * 优点：</span><br><span class="line"> * 1、当线程类已经继承于某个类，但是仍然想实现多线程可用此方式</span><br><span class="line"> * 2、多个线程能共享一个对象的资源（在Thread方式里要设置为静态变量）</span><br><span class="line"> * </span><br><span class="line"> * 本质（总结）：只有Thread类才能实现线程，要么继承它，要么利用Thread的构造函数与Runnable接口进行复制</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//既继承了基类，又实现了接口Runnable的run()方法</span><br><span class="line">class People&#123;</span><br><span class="line">&#125;</span><br><span class="line">class Student extends People implements Runnable&#123;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;我是学生类&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void show() &#123;</span><br><span class="line">		System.out.println(&quot;hhh&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//共享资源例子(继承Thread方式)：火车票分四个窗口售出</span><br><span class="line">class WindowThread extends Thread&#123;</span><br><span class="line">	int ticket=100;</span><br><span class="line">	//static int ticket=100;	//当不设置为static变量时达不到共享一个类资源的效果，并且设置成static消耗较大，jvm不会回收</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(ticket&gt;0)</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+&quot;窗口正在售出第&quot;+(ticket--)+&quot;张票&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//共享资源例子(实现Runnable接口方式)：火车票分四个窗口售出</span><br><span class="line">class Window implements Runnable&#123;</span><br><span class="line">	private int ticket=100;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(ticket&gt;0) &#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+&quot;窗口正在售出第&quot;+(ticket--)+&quot;张票&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class CommonCreateWay &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//设置四个窗口</span><br><span class="line">		/*WindowThread w1=new WindowThread();</span><br><span class="line">		WindowThread w2=new WindowThread();</span><br><span class="line">		WindowThread w3=new WindowThread();</span><br><span class="line">		WindowThread w4=new WindowThread();</span><br><span class="line">		w1.start();w2.start();w3.start();w4.start();*/</span><br><span class="line">		</span><br><span class="line">		Window w=new Window();			//设置一个总窗口</span><br><span class="line">		Thread t=new Thread(w,&quot;窗口1&quot;);	//用四个Thread线程构造四个窗口</span><br><span class="line">		t.start();</span><br><span class="line">		t=new Thread(w,&quot;窗口2&quot;);</span><br><span class="line">		t.start();</span><br><span class="line">		t=new Thread(w,&quot;窗口3&quot;);</span><br><span class="line">		t.start();</span><br><span class="line">		t=new Thread(w,&quot;窗口4&quot;);</span><br><span class="line">		t.start();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="多线程同步："><a href="#多线程同步：" class="headerlink" title="多线程同步："></a>多线程同步：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"> package Multiple__Thread;</span><br><span class="line">/*</span><br><span class="line"> * 线程有几个状态：出生态(刚被创建出来)，就绪态(调用start()方法后开始抢夺CPU资源)，运行态（正在被运行的线程），死亡态（结束线程）</span><br><span class="line"> * 阻塞态（执行一半被搁置的状态）：调用wait(),join(),sleep()等出现状态</span><br><span class="line"> * </span><br><span class="line"> * 当线程进入阻塞态时，可能就会引起线程安全问题。</span><br><span class="line"> * 这时就需要一个同步机制：</span><br><span class="line"> * 一、同步代码块：当操作共享资源时，突然进入阻塞状态会引起安全问题，就需要同步代码块使得一个线程执行完毕后</span><br><span class="line"> * 另一线程才能执行。</span><br><span class="line"> * 格式：synchronized(任意对象)&#123;	//一般称此对象为锁，锁住共享资源只能供一人使用</span><br><span class="line"> * 		同步的代码块（一般为操作共享资源的代码块）</span><br><span class="line"> * &#125;</span><br><span class="line"> * </span><br><span class="line"> * 二、同步方法：锁为当前对象(this)</span><br><span class="line"> * 	格式：权限 synchronized 返回值 方法名()</span><br><span class="line"> * &#125;</span><br><span class="line"> * </span><br><span class="line"> * 单例模式：属于工厂模式的特例，只是它不需要输入参数并且始终返回同一对象的引用（即某类在系统中只有一个实例）</span><br><span class="line"> * 饿汉式：在程序启动或单件模式类被加载的时候，单例模式实例就已经被创建。</span><br><span class="line"> * 懒汉式：当程序第一次访问单例模式实例时才进行创建</span><br><span class="line"> * 若该对象经常被访问使用饿汉式，若该对象不经常被访问使用懒汉式。</span><br><span class="line"> */</span><br><span class="line">//进入阻塞状态后出现的错误</span><br><span class="line">class DangerousWindow implements Runnable&#123;</span><br><span class="line">	private int ticket=100;</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		while(ticket&gt;0) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(15);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			// TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()+&quot;窗口正在售出第&quot;+(ticket--)+&quot;张票&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">class SatefyWindow implements Runnable&#123;</span><br><span class="line">	private int ticket=100;</span><br><span class="line">	Object obj=new Object();</span><br><span class="line">	public void run() &#123;</span><br><span class="line">			//同步代码块</span><br><span class="line">			while(true) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.sleep(20);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					// TODO Auto-generated catch block</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				synchronized(obj) &#123;	//若同步放在while上面即函数开始，会导致只有一个窗口能售票，因为</span><br><span class="line">									//其它窗口刚想售票时（抢夺CPU时）共享资源和CPU会马上被锁住</span><br><span class="line">				if(ticket&gt;0) &#123;				</span><br><span class="line">					</span><br><span class="line">					System.out.println(Thread.currentThread().getName()+&quot;窗口正在售出第&quot;+(ticket--)+&quot;张票&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;break;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//同步方法</span><br><span class="line">			/*while(true) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(15);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">				sale();</span><br><span class="line">			&#125;*/</span><br><span class="line">		&#125;</span><br><span class="line">	public synchronized void sale() &#123;</span><br><span class="line">		if(ticket&gt;0) &#123;				</span><br><span class="line">			</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+&quot;窗口正在售出第&quot;+(ticket--)+&quot;张票&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//饿汉式</span><br><span class="line">class Hungry_Single&#123;</span><br><span class="line">	private static Hungry_Single single=new Hungry_Single();</span><br><span class="line">	public static Hungry_Single get_Single() &#123;</span><br><span class="line">		return single;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//懒汉式（容易引起多线程问题，要使用同步机制）</span><br><span class="line">class Lazy_Single&#123;</span><br><span class="line">	private static Lazy_Single single=null;</span><br><span class="line">	public static Lazy_Single get_Single() &#123;</span><br><span class="line">		if(single==null) &#123;		//让其它线程知道接下来是一个同步代码块,不为空时不用跟着浪费时间，不用处于等待态</span><br><span class="line">		//静态方法里没法使用this，所以使用Lazy_Single.class,一样效果</span><br><span class="line">		synchronized(Lazy_Single.class) &#123;</span><br><span class="line">			if(single==null) &#123;</span><br><span class="line">				single=new Lazy_Single();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return single;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//练习题目：银行有一个账户，有俩个人分别向同一账户存3000元，每次存1000，分三次，每次存完打印账户余额</span><br><span class="line">/*</span><br><span class="line"> * 分析：	是否有多线程？有，俩个人。</span><br><span class="line"> * 			是否有共享资源？有，一个账户。</span><br><span class="line"> * 			是否需要同步机制？需要，当其中一个人操作账户时其它人不能操作</span><br><span class="line"> */</span><br><span class="line">class Account&#123;</span><br><span class="line">	protected float money=0;</span><br><span class="line">	public void save_money(float money) &#123;this.money+=money;</span><br><span class="line">	System.out.println(&quot;当前账户余额：&quot;+this.money);&#125;</span><br><span class="line">	public float get_money() &#123;return money;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Custom implements Runnable&#123;</span><br><span class="line">	Account a;</span><br><span class="line">	Custom(Account a)&#123;this.a=a;&#125;</span><br><span class="line">	public synchronized void run() &#123;</span><br><span class="line">		//当第一线程刚执行完存钱操作后，第二线程又马上进行判断和存钱操作，会引起错误。</span><br><span class="line">		while(a.get_money()&lt;3000)	//当余额高于3000时不必执行以下操作</span><br><span class="line">		&#123;</span><br><span class="line">			a.save_money(1000);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">public class synchronized_ &#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		//DangerousWindow w=new DangerousWindow();			//设置一个总窗口</span><br><span class="line">		SatefyWindow w=new SatefyWindow();					//设置一个总窗口</span><br><span class="line">		Thread t=new Thread(w,&quot;窗口1&quot;);	//用四个Thread线程构造四个窗口</span><br><span class="line">		t.start();</span><br><span class="line">		t=new Thread(w,&quot;窗口2&quot;);</span><br><span class="line">		t.start();</span><br><span class="line">		t=new Thread(w,&quot;窗口3&quot;);</span><br><span class="line">		t.start();</span><br><span class="line">		t=new Thread(w,&quot;窗口4&quot;);</span><br><span class="line">		t.start();</span><br><span class="line">		</span><br><span class="line">		//测试饿汉懒汉</span><br><span class="line">		/*Hungry_Single h1=Hungry_Single.get_Single();</span><br><span class="line">		Lazy_Single h2=Lazy_Single.get_Single();*/</span><br><span class="line">		</span><br><span class="line">		//练习题目测试</span><br><span class="line">		/*Account account=new Account();</span><br><span class="line">		Custom c=new Custom(account);</span><br><span class="line">		Thread t1=new Thread(c);</span><br><span class="line">		Thread t2=new Thread(c);</span><br><span class="line">		t1.start();t2.start();*/</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="多线程通信："><a href="#多线程通信：" class="headerlink" title="多线程通信："></a>多线程通信：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"> package Multiple__Thread;</span><br><span class="line">/*</span><br><span class="line"> * 死锁：是指俩个线程互相有依赖状态，各自进入阻塞态时都在等待对方的锁</span><br><span class="line"> * 避免死锁：1、同步区域拥有各自的锁2、同步代码块用完操作资源后立马释放</span><br><span class="line"> * </span><br><span class="line"> * 多线程通信（合作）：当多个线程需要协作操作同一内存资源（类）时，必须使用通信机制，防止某一线程占用CPU太多出现的问题</span><br><span class="line"> * 通信机制有以下方法：</span><br><span class="line"> * wait():使当前线程进入阻塞态,并释放锁。</span><br><span class="line"> * notify():通知该锁第一个调用wait()线程苏醒(可被其它线程通知，实现一个通信效果)</span><br><span class="line"> * notifyAll():通知该锁所有调用wait()线程苏醒(可被其它线程通知，实现一个通信效果)</span><br><span class="line"> * 注意： 1、以上方法必须和while搭配使用，保证安全性，防止在wait()之前notify()就来通知苏醒</span><br><span class="line"> * 		 2、以上方法的调用对象必须是同步锁对象，否则就会引起异常</span><br><span class="line"> * 		 3、以上方法必须在try catch里使用</span><br><span class="line"> * wait()和sleep()和yield()的区别：yield()是释放CPU当前执行线程，使线程进入就绪态</span><br><span class="line"> * sleep()是使当前CPU执行线程进入阻塞态，wait()是使当前CPU执行线程进入阻塞态，并释放锁(即此时其它线程可进入同步代码)。</span><br><span class="line"> */</span><br><span class="line">//多线程通信</span><br><span class="line">class Storage&#123;</span><br><span class="line">	protected int number[]=new int[20];</span><br><span class="line">	protected int putcount=0,getcount=0;	//记录进出数组数据量</span><br><span class="line">	protected int size=0;	//记录当前数组的规模(数据数)，某一线程过快，每放入或取出数据</span><br><span class="line">							//达到数组规模（满或空状态）时休眠一次</span><br><span class="line">	Object putlock=new Object();</span><br><span class="line">	Object getlock=new Object();</span><br><span class="line">	synchronized void put(int num) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			while(size==number.length) &#123;</span><br><span class="line">				this.wait(); 		//当前数组规模已达容量值，休眠线程</span><br><span class="line">			&#125;</span><br><span class="line">			if(putcount==number.length) &#123;</span><br><span class="line">				putcount=0;			//达到一个循环数组的效果</span><br><span class="line">			&#125;</span><br><span class="line">			number[putcount++]=num;</span><br><span class="line">			size++;	//更新规模</span><br><span class="line">			System.out.println(&quot;向数组放入第&quot;+size+&quot;个元素:&quot;+num);</span><br><span class="line">			this.notify(); 			//从while循环退出后，规模不为满，可以唤醒线程</span><br><span class="line">		&#125;catch(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	synchronized int get() &#123;</span><br><span class="line">		int temp = 0;</span><br><span class="line">		try &#123;</span><br><span class="line">			while(size==0) &#123;</span><br><span class="line">				this.wait(); 		//当前数组规模已为0，线程休眠</span><br><span class="line">			&#125;</span><br><span class="line">			if(getcount==number.length) &#123;</span><br><span class="line">				getcount=0;			//达到一个循环数组的效果</span><br><span class="line">			&#125;</span><br><span class="line">			temp=number[getcount];</span><br><span class="line">			getcount++;</span><br><span class="line">			size--;	//更新规模</span><br><span class="line">			System.out.println(&quot;从数组取出第&quot;+size+&quot;个元素:&quot;+temp);</span><br><span class="line">			this.notify(); 			//从while循环退出后，规模不为空，可以唤醒线程</span><br><span class="line">		&#125;catch(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		return temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class put_Thread implements Runnable&#123;</span><br><span class="line">	private Storage st;</span><br><span class="line">	put_Thread(Storage st)&#123;this.st=st;&#125;</span><br><span class="line">	public synchronized void run() &#123;</span><br><span class="line">		while(true) &#123;</span><br><span class="line">		st.put(0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class get_Thread implements Runnable&#123;</span><br><span class="line">	private Storage st;</span><br><span class="line">	get_Thread(Storage st)&#123;this.st=st;&#125;</span><br><span class="line">	public synchronized void run() &#123;</span><br><span class="line">		while(true) &#123;</span><br><span class="line">		st.get();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">public class deadlock_cooperation &#123;</span><br><span class="line">	//死锁例子：美国人和中国人收集工具，美国人进入阻塞态需要筷子，中国人进入阻塞态需要刀</span><br><span class="line">	static class deadlock implements Runnable&#123;</span><br><span class="line">		private Object chopstickslock=new Object();</span><br><span class="line">		private Object knifelock=new Object();</span><br><span class="line">		boolean judge;</span><br><span class="line">		deadlock(boolean judge)&#123;this.judge=judge;&#125;</span><br><span class="line">		public void run() &#123;</span><br><span class="line">			if(judge) &#123;</span><br><span class="line">				while(true) &#123;</span><br><span class="line">					synchronized(chopstickslock) &#123;</span><br><span class="line">					System.out.println(&quot;中国人已有筷子&quot;);</span><br><span class="line">					//因CPU执行速度太快，必须暂缓一会模拟死锁</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(6000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						// TODO Auto-generated catch block</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">						synchronized(knifelock) &#123;</span><br><span class="line">							System.out.println(&quot;中国人已有筷子已有刀叉&quot;);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				while(true) &#123;</span><br><span class="line">				synchronized(knifelock) &#123;</span><br><span class="line">					System.out.println(&quot;美国人已有刀叉&quot;);</span><br><span class="line">					//因CPU执行速度太快，必须暂缓一会模拟死锁</span><br><span class="line">					try &#123;</span><br><span class="line">						Thread.sleep(6000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						// TODO Auto-generated catch block</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					synchronized(chopstickslock) &#123;</span><br><span class="line">						System.out.println(&quot;美国人已有刀叉已有筷子&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//测试死锁</span><br><span class="line">		/*deadlock China=new deadlock(true);</span><br><span class="line">		deadlock America=new deadlock(false);</span><br><span class="line">		Thread Copen=new Thread(China);</span><br><span class="line">		Thread Aopen=new Thread(America);</span><br><span class="line">		Copen.start();Aopen.start();*/</span><br><span class="line">		</span><br><span class="line">		//测试通信</span><br><span class="line">		Storage s=new Storage();				//s即为同一块内存空间</span><br><span class="line">		put_Thread put=new put_Thread(s);		//放入线程通过构造方式操纵同一块内存空间（类s）</span><br><span class="line">		get_Thread get=new get_Thread(s);		//取出线程通过构造方式操纵同一块内存空间（类s）</span><br><span class="line">		Thread t1=new Thread(put);</span><br><span class="line">		Thread t2=new Thread(get);</span><br><span class="line">		t1.start();t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> * 通信结果：当放入至20个元素时，线程等待,当取出线程已取完时，取出线程等待</span><br><span class="line">			向数组放入第1个元素:0</span><br><span class="line">			向数组放入第2个元素:0</span><br><span class="line">			向数组放入第3个元素:0</span><br><span class="line">			向数组放入第4个元素:0</span><br><span class="line">			向数组放入第5个元素:0</span><br><span class="line">			向数组放入第6个元素:0</span><br><span class="line">			向数组放入第7个元素:0</span><br><span class="line">			向数组放入第8个元素:0</span><br><span class="line">			向数组放入第9个元素:0</span><br><span class="line">			向数组放入第10个元素:0</span><br><span class="line">			向数组放入第11个元素:0</span><br><span class="line">			向数组放入第12个元素:0</span><br><span class="line">			向数组放入第13个元素:0</span><br><span class="line">			向数组放入第14个元素:0</span><br><span class="line">			向数组放入第15个元素:0</span><br><span class="line">			向数组放入第16个元素:0</span><br><span class="line">			向数组放入第17个元素:0</span><br><span class="line">			向数组放入第18个元素:0</span><br><span class="line">			向数组放入第19个元素:0</span><br><span class="line">			向数组放入第20个元素:0</span><br><span class="line">			从数组取出第19个元素:0</span><br><span class="line">			从数组取出第18个元素:0</span><br><span class="line">			从数组取出第17个元素:0</span><br><span class="line">			从数组取出第16个元素:0</span><br><span class="line">			从数组取出第15个元素:0</span><br><span class="line">			从数组取出第14个元素:0</span><br><span class="line">			从数组取出第13个元素:0</span><br><span class="line">			从数组取出第12个元素:0</span><br><span class="line">			从数组取出第11个元素:0</span><br><span class="line">			从数组取出第10个元素:0</span><br><span class="line">			从数组取出第9个元素:0</span><br><span class="line">			从数组取出第8个元素:0</span><br><span class="line">			从数组取出第7个元素:0</span><br><span class="line">			从数组取出第6个元素:0</span><br><span class="line">			从数组取出第5个元素:0</span><br><span class="line">			从数组取出第4个元素:0</span><br><span class="line">			从数组取出第3个元素:0</span><br><span class="line">			从数组取出第2个元素:0</span><br><span class="line">			从数组取出第1个元素:0</span><br><span class="line">			从数组取出第0个元素:0</span><br><span class="line">			向数组放入第1个元素:0</span><br><span class="line">			向数组放入第2个元素:0</span><br><span class="line">			向数组放入第3个元素:0</span><br><span class="line">			向数组放入第4个元素:0</span><br><span class="line">			向数组放入第5个元素:0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>





      
    </div>
    <footer class="article-footer">
      <a data-url="https://mrqlyn.github.io/2019/07/14/java基础/Java多线程代码/" data-id="ckib8b2oh008cvctptcufbr2d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java基础/">Java基础</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/07/14/java基础/Java容器代码/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java容器代码
        
      </div>
    </a>
  
  
    <a href="/2019/07/14/java基础/Java反射代码/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java反射代码</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java基础/">Java基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web高阶/">Web高阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基础操作/">基础操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库/">数据库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 18.57px;">Android</a> <a href="/tags/C/" style="font-size: 12.86px;">C++</a> <a href="/tags/Git/" style="font-size: 11.43px;">Git</a> <a href="/tags/Java基础/" style="font-size: 15.71px;">Java基础</a> <a href="/tags/Web/" style="font-size: 20px;">Web</a> <a href="/tags/Web高阶/" style="font-size: 18.57px;">Web高阶</a> <a href="/tags/前端/" style="font-size: 14.29px;">前端</a> <a href="/tags/基础操作/" style="font-size: 10px;">基础操作</a> <a href="/tags/数据库/" style="font-size: 15.71px;">数据库</a> <a href="/tags/数据结构与算法/" style="font-size: 17.14px;">数据结构与算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/14/前端/Bootstrap笔记（二）/">Bootstrap笔记（二）</a>
          </li>
        
          <li>
            <a href="/2019/07/14/前端/Bootstrap笔记（一）/">Bootstrap笔记（一）</a>
          </li>
        
          <li>
            <a href="/2019/07/14/Web高阶/SpringBoot开发总结/">SpringBoot开发总结</a>
          </li>
        
          <li>
            <a href="/2019/07/14/Web高阶/springboot项目中使用mybatis逆向工程生成代码实例/">springboot项目中使用mybatis逆向工程生成代码实例</a>
          </li>
        
          <li>
            <a href="/2019/07/14/Web高阶/SpringMVC对网页发来的数据请求处理和转发/">SpringMVC对网页发来的数据请求处理和转发</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Qin Lin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>